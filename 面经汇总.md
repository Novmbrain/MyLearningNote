# 面经汇总

## Java虚拟机

### Java中线程同步的方案有哪些？

同步是指当多个线程并发的访问共享数据时，保证共享数据在同一时刻只会被一条线程访问

> 当使用信号量时，同步能够保证共享数据在同一时刻被一些线程所访问

#### 阻塞同步方案

##### synchronized关键字

它是一种块结构的同步语法。synchronized关键字在经过javac编译后，会在同步块前后形成monitorenter和monitorexit两个字节码指令。

在执行monitorenter指令时，首先要去尝试获取对象的锁，

- 如果对象没有被锁定，或者当前线程已经持有那个对象的说，就把锁的计数器的值增加1,。而在执行monitorexit指令时会将计数器的值减一。一旦计数器的值为0，锁就被释放
- 如果获取对象锁失败，则当前线程被阻塞等待，直到请求的对象被持有它的线程释放为止

synchronized同步块对于同一条线程是可以重入的。



##### 可重入锁（ReentrantLock）

JUC的Lock接口提供了在类库层面实现同步，ReentrantLock是Lock接口最常见的实现，它和synchronized一样是可重入的。

相比于synchronized，它加入了三个高级功能

- 等待可以中断：持有锁的线程长期不释放锁的时候，正在等待的线程可以选择放弃等待，改为处理其他事情
- 公平锁：ReeentranLock在默认情况下和synchronized一样也是非公平的，但是可以通过构造函数设置成公平锁

#### 非阻塞同步方案

Java的线程是映射到操作系统的原生线程上的，所以线程的阻塞和唤醒都需要在用户态和内核态之间切换，这种切换非常的消耗时间。非阻塞同步方案能够解决这个问题。

阻塞同步方案实际上是一种悲观的并发策略，而非阻塞同步方案是一种乐观的策略

系统指令集层面支持CAS操作的原子性，Java通过CAS操作，实现无锁方案。Java类库的atomic包下提供了一组原子操作的封装类。但是非阻塞同步方案并不能够覆盖阻塞同步方案的全部场景，仅适用于计数器和累加器这样的功能

#### 无同步方案

如果一段代码不涉及共享数据，那么这些代码天生就是线程安全的。

- 可重入代码（Reentrant Code）：在代码执行的任何时刻中断它，转而去执行另一端代码，而在控制权返回后，原来的程序不会出现任何错误。
- 线程本地储存（Thread Local Storage）：如果访问共享数据的代码仅在一个线程内，我们就可以把共享数据的可 见范围限制在同一个线程之内，这样，无须同步也能保证线程之间不出现数据争用的问题。ThreadLocal提供了仅在本线程内可见的变量







