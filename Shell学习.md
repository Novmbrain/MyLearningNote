# Shell学习

## 初识是Shell

```
[me@linuxbox ~]$
```

shell 提示符：用户名@主机名，紧接着当前工作目录和一个美元符号。**如果提示符的最后一个字符是“#”, 而不是“$”, 那么这个终端会话就有超级用户权限。**

如果按下上箭头按键，我们会看到刚才输入的命令“kaekfjaeifj”重新出现在提示符之后。 这就叫做命令历史。许多 Linux 发行版默认保存最后输入的500个命令

不要在一个终端窗口里使用 Ctrl-c 和 Ctrl-v 快捷键来执行拷贝和粘贴操作。 它们不起作用。对于 shell 来说，这两个控制代码有着不同的含义，它们在早于 Microsoft Windows （定义复制粘贴的含义）许多年之前就赋予了不同的意义。

X 窗口系统 （使 GUI 工作的底层引擎）内建了一种机制，支持快速拷贝和粘贴技巧。 如果你按下鼠标左键，沿着文本拖动鼠标（或者双击一个单词）高亮了一些文本， 那么这些高亮的文本就被拷贝到了一个由 X 管理的缓冲区里面。然后按下鼠标中键， 这些文本就被粘贴到光标所在的位置。



一些简单的命令

```
查看磁盘剩余空间的数量，输入 df

显示空闲内存的数量，输入命令 free

是在 shell 提示符下输入 exit 命令来终止一个终端会话
```

## 在文件系统中跳转

```
命令总览：

pwd - Print name of current working directory

cd - Change directory
输入 cd, 然后输入你想要去的工作目录的路径名。
路径名可通过两种方式来指定，一种是绝对路径， 另一种是相对路径。

ls - List directory contents
用 ls 命令可以列出任一个目录的内容，而不只是当前工作目录的内容。
```

一个“类 Unix” 的操作系统，比如说 Linux，以分层目录结构来组织所有文件。 这就意味着所有文件组成了一棵树型目录。文件系统中的第一级目录称为根目录。 根目录包含文件和子目录，子目录包含更多的文件和子目录，依此类推。

注意(类 Unix 系统)不像 Windows ，每个存储设备都有一个独自的文件系统树。类 Unix 操作系统， 比如 Linux，总是只有一个单一的文件系统树，不管有多少个磁盘或者存储设备连接到计算机上。 根据负责维护系统安全的系统管理员的兴致，存储设备连接到（或着更精确些，是挂载到）目录树的各个节点上。

当我们首次登录系统（或者启动终端仿真器会话）后，当前工作目录是我们的家目录。 每个用户都有他自己的家目录，当用户以普通用户的身份操控系统时，家目录是唯一 允许用户写入文件的地方。

### 绝对路径和相对路径

- 绝对路径开始于根目录，紧跟着目录树的一个个分支，一直到达所期望的目录或文件。 根目录（用开头的”/”表示）
- 相对路径开始于工作目录。 为了做到这个（用相对路径表示）， 我们在文件系统树中用一对特殊符号来表示相对位置。 这对特殊符号是 “.” (点) 和 “..” (点点)。
- 符号 “.” 指的是工作目录，”..” 指的是工作目录的父目录。
- 有一件很重要的事，在几乎所有的情况下，你可以省略”./”。它是隐含的
- 如果不指定一个文件的路径，那它被默认为在当前工作目录下

```bash
w20fu@w20fu-VirtualBox:/$ cd usr
w20fu@w20fu-VirtualBox:/usr$ cd ..
w20fu@w20fu-VirtualBox:/$ cd ./usr
w20fu@w20fu-VirtualBox:/usr$ 
```

| Shortcut      | Result                                                       |
| :------------ | :----------------------------------------------------------- |
| cd            | Changes the working directory to your home directory.        |
| cd -          | Changes the working directory to the previous working directory. |
| cd ~user_name | Changes the working directory to the home directory of user_name. For example, cd ~bob will change the directory to the home directory of user “bob.” |

关于文件名的重要规则

1. 以 “.” 字符开头的文件名是隐藏文件。这仅表示，ls 命令不能列出它们， 用 ls -a 命令就可以了。当你创建帐号后，几个配置帐号的隐藏文件被放置在 你的家目录下。稍后，我们会仔细研究一些隐藏文件，来定制你的系统环境。 另外，一些应用程序也会把它们的配置文件以隐藏文件的形式放在你的家目录下面。
2. 文件名和命令名是大小写敏感的。文件名 “File1” 和 “file1” 是指两个不同的文件名。
3. Linux 没有“文件扩展名”的概念，不像其它一些系统。可以用你喜欢的任何名字 来给文件起名。文件内容或用途由其它方法来决定。虽然类 Unix 的操作系统， 不用文件扩展名来决定文件的内容或用途，但是有些应用程序会。
4. 虽然 Linux 支持长文件名，文件名可能包含空格，标点符号，但标点符号仅限 使用 “.”，“－”，下划线。最重要的是，不要在文件名中使用空格。如果你想表示词与 词间的空格，用下划线字符来代替。将来你就会明白这样做的好处。

## 探究操作系统

### ls命令

```bash
ls - List directory contents
用 ls 命令可以列出任一个目录的内容，而不只是当前工作目录的内容。并且可以同时列出多个目录

w20fu@w20fu-VirtualBox:/dev$ ls ~
Desktop    Music           Pictures             snap       下载
Documents  OSLearning      Public               Templates
Downloads  ostep-homework  riscv-gnu-toolchain  Videos
w20fu@w20fu-VirtualBox:/dev$ ls /usr ~
/home/w20fu:
Desktop    Music           Pictures             snap       下载
Documents  OSLearning      Public               Templates
Downloads  ostep-homework  riscv-gnu-toolchain  Videos

/usr:
bin    include  lib32  libexec  local              sbin   src
games  lib      lib64  libx32   riscv64-linux-gnu  share


使用 ls 命令的“-l”选项，则结果以长模式输出。
w20fu@w20fu-VirtualBox:~$ ls -l
total 52
drwxr-xr-x  2 w20fu w20fu 4096 Sep 28 21:58 Desktop
drwxr-xr-x  2 w20fu w20fu 4096 Sep 28 21:58 Documents
drwxr-xr-x  2 w20fu w20fu 4096 Sep 28 21:58 Downloads
drwxr-xr-x  2 w20fu w20fu 4096 Sep 28 21:58 Music
drwxrwxr-x  3 w20fu w20fu 4096 May 13 15:49 OSLearning
drwx------ 32 w20fu w20fu 4096 May 26 22:05 ostep-homework
drwxr-xr-x  2 w20fu w20fu 4096 Sep 28 21:58 Pictures
drwxr-xr-x  2 w20fu w20fu 4096 Sep 28 21:58 Public
drwxrwxr-x 23 w20fu w20fu 4096 May 26 01:36 riscv-gnu-toolchain
drwxr-xr-x  3 w20fu w20fu 4096 May 27 18:05 snap
drwxr-xr-x  2 w20fu w20fu 4096 Sep 28 21:58 Templates
drwxr-xr-x  2 w20fu w20fu 4096 Sep 28 21:58 Videos
drwxr-xr-x  2 w20fu w20fu 4096 May 13 15:48 下载

```

### 命令的选项和参数

命令名经常会带有一个或多个用来改变命令行为的选项， 更进一步，选项后面会带有一个或多个参数，这些参数是命令作用的对象。所以大多数命令看起来像这样：

```
command -options arguments
```

### 长格式输出

“-l”选项导致 ls 的输出结果以长格式输出。

```
-rw-r--r-- 1 root root 3576296 2007-04-03 11:05 Experience ubuntu.ogg
```

|                  |                                                              |
| :--------------- | :----------------------------------------------------------- |
| 字段             | 含义                                                         |
| -rw-r--r--       | 对于文件的访问权限。第一个字符指明文件类型。在不同类型之间， 开头的“－”说明是一个普通文件，“d”表明是一个目录。其后三个字符是文件所有者的 访问权限，再其后的三个字符是文件所属组中成员的访问权限，最后三个字符是其他所 有人的访问权限。这个字段的完整含义将在第十章讨论。 |
| 1                | 文件的硬链接数目。参考随后讨论的关于链接的内容。             |
| root             | 文件所有者的用户名。                                         |
| root             | 文件所属用户组的名字。                                       |
| 32059            | 以字节数表示的文件大小。                                     |
| 2007-04-03 11:05 | 上次修改文件的时间和日期。                                   |
| oo-cd-cover.odf  | 文件名                                                       |

### 确定文件类型

与 Windows 操作系统不同，文件的扩展名对 Linux 操作系统没有特殊的含义，换句话说，Linux 系统并不以文件的扩展名开分区文件类型。

```
file filename
```

Linux 中，有个普遍的观念就是“一切皆文件”。

### less命令

`less`与文本编辑器（如`vim`或`nano`）相比，启动时不会读取整个文件从而使加载时间大大缩短。

`less`命令主要用于打开[大文件](https://www.myfreax.com/find-large-files-in-linux/)。

```
less filename
```

| Page UP or b       | 向上翻滚一页                                             |
| ------------------ | -------------------------------------------------------- |
| Page Down or space | 向下翻滚一页                                             |
| UP Arrow           | 向上翻滚一行                                             |
| Down Arrow         | 向下翻滚一行                                             |
| G                  | 移动到最后一行                                           |
| 1G or g            | 移动到开头一行                                           |
| /charaters         | 向前查找指定的字符串                                     |
| n                  | 向前查找下一个出现的字符串，这个字符串是之前所指定查找的 |
| h                  | 显示帮助屏幕                                             |
| q                  | 退出 less 程序                                           |

#### linux文件目录

| 目录           | 评论                                                         |
| :------------- | :----------------------------------------------------------- |
| /              | 根目录，万物起源。                                           |
| /bin           | 包含系统启动和运行所必须的二进制程序。                       |
| /boot          | 包含 Linux 内核、初始 RAM 磁盘映像（用于启动时所需的驱动）和 启动加载程序。有趣的文件：/boot/grub/grub.conf or menu.lst， 被用来配置启动加载程序。/boot/vmlinuz，Linux 内核。 |
| /dev           | 这是一个包含设备结点的特殊目录。“一切都是文件”，也适用于设备。 在这个目录里，内核维护着所有设备的列表。 |
| /etc           | 这个目录包含所有系统层面的配置文件。它也包含一系列的 shell 脚本， 在系统启动时，这些脚本会开启每个系统服务。这个目录中的任何文件应该是可读的文本文件。有趣的文件：虽然/etc 目录中的任何文件都有趣，但这里只列出了一些我一直喜欢的文件：/etc/crontab， 定义自动运行的任务。/etc/fstab，包含存储设备的列表，以及与他们相关的挂载点。/etc/passwd，包含用户帐号列表。 |
| /home          | 在通常的配置环境下，系统会在 /home 下，给每个用户分配一个目录。普通用户只能 在自己的目录下写文件。这个限制保护系统免受错误的用户活动破坏。 |
| /lib           | 包含核心系统程序所使用的共享库文件。这些文件与 Windows 中的动态链接库相似。 |
| /lost+found    | 每个使用 Linux 文件系统的格式化分区或设备，例如 ext3文件系统， 都会有这个目录。当部分恢复一个损坏的文件系统时，会用到这个目录。这个目录应该是空的，除非文件系统 真正的损坏了。 |
| /media         | 在现在的 Linux 系统中，/media 目录会包含可移动介质的挂载点， 例如 USB 驱动器，CD-ROMs 等等。这些介质连接到计算机之后，会自动地挂载到这个目录结点下。 |
| /mnt           | 在早些的 Linux 系统中，/mnt 目录包含可移动介质的挂载点。     |
| /opt           | 这个/opt 目录被用来安装“可选的”软件。这个主要用来存储可能 安装在系统中的商业软件产品。 |
| /proc          | 这个/proc 目录很特殊。从存储在硬盘上的文件的意义上说，它不是真正的文件系统。 相反，它是一个由 Linux 内核维护的虚拟文件系统。它所包含的文件是内核的窥视孔。这些文件是可读的， 它们会告诉你内核是怎样监管计算机的。 |
| /root          | root 帐户的家目录。                                          |
| /sbin          | 这个目录包含“系统”二进制文件。它们是完成重大系统任务的程序，通常为超级用户保留。 |
| /tmp           | 这个/tmp 目录，是用来存储由各种程序创建的临时文件的地方。系统每次 重新启动时，都会清空这个目录。 |
| /usr           | 在 Linux 系统中，/usr 目录可能是最大的一个。它包含普通用户所需要的所有程序和文件。 |
| /usr/bin       | /usr/bin 目录包含系统安装的可执行程序。通常，这个目录会包含许多程序。 |
| /usr/lib       | 包含由/usr/bin 目录中的程序所用的共享库。                    |
| /usr/local     | 这个/usr/local 目录，是非系统发行版自带程序的安装目录。 通常，由源码编译的程序会安装在/usr/local/bin 目录下。新安装的 Linux 系统中会存在这个目录， 并且在管理员安装程序之前，这个目录是空的。 |
| /usr/sbin      | 包含许多系统管理程序。                                       |
| /usr/share     | /usr/share 目录包含许多由 /usr/bin 目录中的程序使用的共享数据。 其中包括像默认的配置文件、图标、桌面背景、音频文件等等。 |
| /usr/share/doc | 大多数安装在系统中的软件包会包含一些文档。在/usr/share/doc 目录下， 我们可以找到按照软件包分类的文档。 |
| /var           | 除了/tmp 和/home 目录之外，相对来说，目前我们看到的目录是静态的，这是说， 它们的内容不会改变。/var 目录存放的是动态文件。各种数据库，假脱机文件， 用户邮件等等，都位于在这里。 |
| /var/log       | 这个/var/log 目录包含日志文件、各种系统活动的记录。这些文件非常重要，并且 应该时时监测它们。其中最重要的一个文件是 /var/log/messages。注意，为了系统安全，在一些系统中， 你必须是超级用户才能查看这些日志文件。 |

### 链接

```
lrwxrwxrwx 1 root root 11 2007-08-11 07:34 libc.so.6 -> libc-2.6.so
```

这条信息第一个字符是“l”，并且有两个文件名呢？ 这是一个特殊文件，叫做符号链接（也称为软链接或者 symlink ）。 在大多数“类 Unix” 系统中， 有可能一个文件被多个文件名所指向。



#### inode与符号链接

[阮一峰](https://www.ruanyifeng.com/blog/2011/12/inode.html)

##### inode存储什么

文件储存在硬盘上，硬盘的最小存储单位叫做"扇区"（Sector）。每个扇区储存512字节（相当于0.5KB）。

操作系统读取硬盘的时候，不会一个个扇区地读取，这样效率太低，而是一次性连续读取多个扇区，即一次性读取一个"块"（block）。这种由多个扇区组成的"块"，是文件存取的最小单位。"块"的大小，最常见的是4KB，即连续八个 sector组成一个 block。

文件数据都储存在"块"中，那么很显然，我们还必须找到一个地方储存文件的元信息，比如文件的创建者、文件的创建日期、文件的大小等等。这种储存文件元信息的区域就叫做inode，中文译名为"索引节点"。

每一个文件都有对应的inode，里面包含了与该文件有关的一些信息。如下

```
　　* 文件的字节数

　　* 文件拥有者的User ID

　　* 文件的Group ID

　　* 文件的读、写、执行权限

　　* 文件的时间戳，共有三个：ctime指inode上一次变动的时间，mtime指文件内容上一次变动的时间，atime指文件上一次打开的时间。

　　* 链接数，即有多少文件名指向这个inode

　　* 文件数据block的位置
```

可以用stat命令，查看某个文件的inode信息：

```
　stat example.txt
```

![image-20210929115622728](Shell%E5%AD%A6%E4%B9%A0.assets/image-20210929115622728.png)

##### inode大小

inode也会消耗硬盘空间，所以硬盘格式化的时候，操作系统自动将硬盘分成两个区域。一个是数据区，存放文件数据；另一个是inode区（inode table），存放inode所包含的信息。

每个inode节点的大小，一般是128字节或256字节。inode节点的总数，在格式化时就给定，一般是每1KB或每2KB就设置一个inode。假定在一块1GB的硬盘中，每个inode节点的大小为128字节，每1KB就设置一个inode，那么inode table的大小就会达到128MB，占整块硬盘的12.8%。

查看每个硬盘分区的inode总数和已经使用的数量，可以使用df命令。

```
　　df -i
```

##### inode号码

每个inode都有一个号码，操作系统用inode号码来识别不同的文件。

这里值得重复一遍，Unix/Linux系统内部不使用文件名，而使用inode号码来识别文件。对于系统来说，文件名只是inode号码便于识别的别称或者绰号。

表面上，用户通过文件名，打开文件。实际上，系统内部这个过程分成三步：首先，系统找到这个文件名对应的inode号码；其次，通过inode号码，获取inode信息；最后，根据inode信息，找到文件数据所在的block，读出数据。

使用ls -i命令，可以看到文件名对应的inode号码：

```
　ls -i example.txt
```

##### indoe与目录文件

Unix/Linux系统中，目录（directory）也是一种文件。打开目录，实际上就是打开目录文件。

目录文件的结构非常简单，就是一系列目录项（dirent）的列表。每个目录项，由两部分组成：所包含文件的文件名，以及该文件名对应的inode号码。

ls命令只列出目录文件中的所有文件名：

> 　　ls /etc

![image-20210929120322960](Shell%E5%AD%A6%E4%B9%A0.assets/image-20210929120322960.png)

ls -i命令列出整个目录文件，即文件名和inode号码：

> 　　ls -i /etc

![image-20210929120338914](Shell%E5%AD%A6%E4%B9%A0.assets/image-20210929120338914.png)

如果要查看文件的详细信息，就必须根据inode号码，访问inode节点，读取信息。ls -l命令列出文件的详细信息。

> 　　ls -l /etc

![image-20210929120404794](Shell%E5%AD%A6%E4%B9%A0.assets/image-20210929120404794.png)

理解了上面这些知识，就能理解目录的权限。目录文件的读权限（r）和写权限（w），都是针对目录文件本身。由于目录文件内只有文件名和inode号码，所以如果只有读权限，只能获取文件名，无法获取其他信息，因为其他信息都储存在inode节点中，而读取inode节点内的信息需要目录文件的执行权限（x）

#### 硬链接

你要记得一个文件至少有一个硬链接，因为文件 名就是由链接创建的

一般情况下，文件名和inode号码是"一一对应"关系，每个inode号码对应一个文件名。但是，Unix/Linux系统允许，多个文件名指向同一个inode号码。

当考虑到硬链接的时候，我们可以假设文件由两部分组成：包含文件内容的数据部分和持有文件名的名字部分 ，这将有助于我们理解这个概念。当我们创建文件硬链接的时候，实际上是为文件创建了额外的名字部分， 并且这些名字都关联到相同的数据部分。这时系统会分配一连串的磁盘块给所谓的索引节点，然后索引节点与文 件名字部分相关联。因此每一个硬链接都指向一个包含文件内容的索引节点。

这意味着，可以用不同的文件名访问同样的内容；对文件内容进行修改，会影响到所有文件名；但是，删除一个文件名，不影响另一个文件名的访问。这种情况就被称为"硬链接"（hard link）。

当一个硬链接被删除时，这个链接 被删除，但是文件本身的内容仍然存在（这是说，它所占的磁盘空间不会被释放）， 直到所有关联这个文件的链接都删除掉

ln命令可以创建硬链接：

```
　ln 源文件 目标文件
```

![image-20210929120735212](Shell%E5%AD%A6%E4%B9%A0.assets/image-20210929120735212.png)

这里顺便说一下目录文件的"链接数"。创建目录时，默认会生成两个目录项："."和".."。前者的inode号码就是当前目录的inode号码，等同于当前目录的"硬链接"；后者的inode号码就是当前目录的父目录的inode号码，等同于父目录的"硬链接"。所以，任何一个目录的"硬链接"总数，总是等于2加上它的子目录总数（含隐藏目录）。

#### 软链接

建立符号链接的目的是为了克服硬链接的两个缺点：硬链接不能跨越物理设备， 硬链接不能关联目录，只能是文件。符号链接是文件的特殊类型，它包含一个指向 目标文件或目录的文本指针。

文件A和文件B的inode号码虽然不一样，但是文件A的内容是文件B的路径。读取文件A时，系统会自动将访问者导向文件B。因此，无论打开哪一个文件，最终读取的都是文件B。这时，文件A就称为文件B的"软链接"（soft link）或者"符号链接（symbolic link）。

这意味着，文件A依赖于文件B而存在，如果删除了文件B，打开文件A就会报错："No such file or directory"。这是软链接与硬链接最大的不同：**文件A指向文件B的文件名**，而不是文件B的inode号码，文件B的inode"链接数"不会因此发生变化。

ln -s命令可以创建软链接。

```
　　ln -s 源文文件或目录 目标文件或目录
```

```bash
[me@linuxbox playground]$ ln -s fun fun-sym
[me@linuxbox playground]$ ln -s ../fun dir1/fun-sym
[me@linuxbox playground]$ ln -s ../fun dir2/fun-sym

[me@linuxbox playground]$ ls -l dir1
total 4
-rw-r--r-- 4 me  me 1650 2008-01-10 16:33 fun-hard
lrwxrwxrwx 1 me  me    6 2008-01-15 15:17 fun-sym -> ../fun

目录 dir1 中，fun-sym 的列表说明了它是一个符号链接，通过在第一字段中的首字符”l” 可知，并且它还指向”../fun”，也是正确的。相对于 fun-sym 的存储位置，fun 在它的 上一个目录。同时注意，符号链接文件的长度是6，这是字符串”../fun”所包含的字符数， 而不是符号链接所指向的文件长度。
```

最后，由于创建符号链接的方式，有可能造成所谓的悬空引用（dangling reference）。如果一个符号链接指向的目标文件已经被删除了，使用这个符号链接会出现下面的消息

```
[me@linuxbox playground]$ less fun-sym
fun-sym: No such file or directory
```

对于符号链接，有一点值得记住，执行的大多数文件操作是针对链接的对象，而不是链接本身。 而 rm 命令是个特例。当你删除链接的时候，删除链接本身，而不是链接的对象

## 操作文件和目录

```
cp – Copy files and directories

mv – Move/rename files and directories

mkdir – Create directories

rm – Remove files and directories

ln – Create hard and symbolic links

cp — 复制文件和目录

mv — 移动/重命名文件和目录

mkdir — 创建目录

rm — 删除文件和目录

ln — 创建硬链接和符号链接
```

###  通配符

接受文件名作为参数的任何命令，都可以使用通配符

常用的通配符

| Wildcard      | Meaning                                                      |
| :------------ | :----------------------------------------------------------- |
| *             | Matches any characters                                       |
| ?             | Matches any single character                                 |
| [characters]  | Matches any character that is a member of the set characters |
| [!characters] | Matches any character that is not a member of the set characters |
| [[:class:]]   | Matches any character that is a member of the specified class |

| 字符类    | 意义                   |
| :-------- | :--------------------- |
| [:alnum:] | 匹配任意一个字母或数字 |
| [:alpha:] | 匹配任意一个字母       |
| [:digit:] | 匹配任意一个数字       |
| [:lower:] | 匹配任意一个小写字母   |
| [:upper:] | 匹配任意一个大写字母   |

| 模式                   | 匹配对象                                                  |
| :--------------------- | :-------------------------------------------------------- |
| *                      | 所有文件                                                  |
| g*                     | 文件名以“g”开头的文件                                     |
| b*.txt                 | 以"b"开头，中间有零个或任意多个字符，并以".txt"结尾的文件 |
| Data???                | 以“Data”开头，其后紧接着3个字符的文件                     |
| [abc]*                 | 文件名以"a","b",或"c"开头的文件                           |
| BACKUP.[0-9][0-9][0-9] | 以"BACKUP."开头，并紧接着3个数字的文件                    |
| [[:upper:]]*           | 以大写字母开头的文件                                      |
| [![:digit:]]*          | 不以数字开头的文件                                        |
| *[[:lower:]123]        | 文件名以小写字母结尾，或以 “1”，“2”，或 “3” 结尾的文件    |

### mkdir - 创建目录

mkdir 命令是用来创建目录的。它这样工作：

```
mkdir directory...

注意: 在描述一个命令时（如上所示），当有三个圆点跟在一个命令的参数后面， 这意味着那个参数可以跟多个，就像这样：
```

### cp - 复制文件和目录

cp 命令，复制文件或者目录。它有两种使用方法：

```
cp item1 item2
复制单个文件或目录”item1”到文件或目录”item2”。如果将文件复制到文件上就是进行覆盖操作

cp item... directory
复制多个项目（文件或目录）到一个目录下。
```

| 选项              | 意义                                                         |
| :---------------- | :----------------------------------------------------------- |
| -a, --archive     | 复制文件和目录，以及它们的属性，包括拥有者和所有权。 通常情况下，文件拷贝具有执行拷贝操作的用户的默认属性。 |
| -i, --interactive | 在覆盖已存在文件之前，提示用户确认。如果这个选项不指定， cp 命令会默认覆盖文件。 |
| -r, --recursive   | 递归地复制目录及目录中的内容。当复制目录时， 需要这个选项（或者 -a 选项）。 |
| -u, --update      | 当把文件从一个目录复制到另一个目录时，仅复制 目标目录中不存在的文件，或者是文件内容新于目标目录中已经存在文件的内容的文件。 |
| -v, --verbose     | 显示翔实的命令操作信息（也就是打印出操作信息）               |



| cp file1 file2      | 复制文件 file1 内容到文件 file2。如果 file2 已经存在， file2 的内容会被 file1 的内容覆盖。如果 file2 不存在，则会创建 file2。 |
| ------------------- | ------------------------------------------------------------ |
| cp -i file1 file2   | 这条命令和上面的命令一样，除了如果文件 file2 存在的话，在文件 file2 被覆盖之前， 会提示用户确认信息。 |
| cp file1 file2 dir1 | 复制文件 file1 和文件 file2 到目录 dir1。目录 dir1 必须存在。 |
| cp dir1/* dir2      | 使用一个通配符，在目录 dir1 中的所有文件都被复制到目录 dir2 中。 dir2 必须已经存在。 |
| cp -r dir1 dir2     | **复制目录 dir1 中的内容到目录 dir2。如果目录 dir2 不存在， 创建目录 dir2**，操作完成后，目录 dir2 中的内容和 dir1 中的一样。 如果目录 dir2 存在，则目录 dir1 (和目录中的内容)将会被复制到 dir2 中。 |

### mv - 移动和重命名文件

mv 命令可以执行文件移动和文件命名任务，这取决于你怎样使用它。任何一种 情况下，完成操作之后，原来的文件名不再存在。mv 使用方法与 cp 很相像：

```
mv item1 item2
把文件或目录 “item1” 移动或重命名为 “item2”, 或者：

mv item... directory
把一个或多个条目从一个目录移动到另一个目录中
```

### rm - 删除文件和目录

rm 命令用来删除文件和目录：

```
rm item...
```

| 选项              | 意义                                                         |
| :---------------- | :----------------------------------------------------------- |
| -i, --interactive | 在删除已存在的文件前，提示用户确认信息。 **如果不指定这个选项，rm 会默默地删除文件** |
| -r, --recursive   | 递归地删除文件，这意味着，如果要删除一个目录，而此目录 又包含子目录，那么子目录也会被删除。要删除一个目录，必须指定这个选项。 |
| -f, --force       | 忽视不存在的文件，不显示提示信息。这选项覆盖了“--interactive”选项。 |
| -v, --verbose     | 在执行 rm 命令时，显示翔实的操作信息。                       |

| 命令              | 运行结果                                                     |
| :---------------- | :----------------------------------------------------------- |
| rm file1          | 默默地删除文件                                               |
| rm -i file1       | 除了在删除文件之前，提示用户确认信息之外，和上面的命令作用一样。 |
| rm -r file1 dir1  | 删除文件 file1, 目录 dir1，及 dir1 中的内容。                |
| rm -rf file1 dir1 | 同上，除了如果文件 file1，或目录 dir1 不存在的话，rm 仍会继续执行。 |

关于rm的tip

```
Be Careful With rm!

小心 rm!

Unix-like operating systems such as Linux do not have an undelete command. Once you delete something with rm, it’s gone. Linux assumes you’re smart and you know what you’re doing.

类 Unix 的操作系统，比如说 Linux，没有复原命令。一旦你用 rm 删除了一些东西， 它就消失了。Linux 假定你很聪明，你知道你在做什么。

Be particularly careful with wildcards. Consider this classic example. Let’s say you want to delete just the HTML files in a directory. To do this, you type:

尤其要小心通配符。思考一下这个经典的例子。假如说，你只想删除一个目录中的 HTML 文件。输入：

rm *.html

which is correct, but if you accidentally place a space between the “*” and the “.html” like so:

这是正确的，如果你不小心在 “*” 和 “.html” 之间多输入了一个空格，就像这样：

rm * .html

the rm command will delete all the files in the directory and then complain that there is no file called “.html”.

这个 rm 命令会删除目录中的所有文件，还会抱怨没有文件叫做 “.html”。

Here is a useful tip. Whenever you use wildcards with rm (besides carefully checking your typing!), test the wildcard first with ls. This will let you see the files that will be deleted. Then press the up arrow key to recall the command and replace the ls with rm.

小贴士。 当你使用带有通配符的 rm 命令时（除了仔细检查输入的内容外）， 先用 ls 命令来测试通配符。这会让你看到将要被删除的文件是什么。然后按下上箭头按键，重新调用 刚刚执行的命令，用 rm 替换 ls。
```

## 什么是命令

### type命令

type 命令是 shell 内部命令，它会显示命令的类型，给出一个特定的命令名（做为参数）。 它像这样工作：

```
type command
```

### whick - 显示一个可执行程序的位置

```
[me@linuxbox ~]$ which ls
/bin/ls
```

which 命令只对可执行程序有效，不包括内建命令和命令别名。 当我们试着使用 shell 内建命令时，例如，cd 命令，我们或者得不到回应，或者是个错误信息：

### help相关的命令

#### help

bash 有一个内建的 help 命令，可查找每一个 shell 内建命令的文档。输入“help”，接着是 shell 内部命令名。

```
[me@linuxbox ~]$ help cd
cd: cd [-L|-P] [dir]
Change ...

注意：出现在命令语法说明中的方括号证的内容是可选的项目。一个竖杠字符 表示互斥选项。在上面 cd 命令的例子中：
```

#### --help

**许多可执行程序支持一个 --help 选项**，这个选项是显示命令所支持的语法和选项说明。例如：                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        

```
[me@linuxbox ~]$ mkdir --help
Usage: mkdir [OPTION] DIRECTORY...
Create ...
```

#### man

许多希望被命令行使用的可执行程序，提供了一个正式的文档，叫做手册或手册页(man page)。一个特殊的叫做 man 的分页程序，可用来浏览他们

```
man program
```

在大多数 Linux 系统中，man 使用 less 工具来显示参考手册，所以当浏览文档时，你所熟悉的 less 命令都能有效。

#### apropos

我们也可以搜索全部参考手册来找到自己需要的命令，这个方法虽然很粗糙但有时很有用。 下面是一个以”floppy”为关键词来搜索参考手册的例子：

```
[me@linuxbox ~]$ apropos floppy
create_floppy_devices (8)   - udev callout to create all possible
...
```

#### whatis -简单的命令手册

whatis 程序显示匹配特定关键字的手册页的名字和一行命令说明：



### alias创建自己的命令

开始之前，我们需要展示一个命令行小技巧。可以把多个命令放在同一行上，命令之间 用”;”分开。它像这样工作：

```
command1; command2; command3...
```

```
[me@linuxbox ~]$ cd /usr; ls; cd -
bin  games    kerberos  lib64    local  share  tmp
...
[me@linuxbox ~]$
```

```
格式：alias name='string'

注意在使用alias之前先用type检验一下是否这个名字已经被某个函数占用

[me@linuxbox ~]$ alias foo='cd /usr; ls; cd -'

在命令”alias”之后，输入“name”，紧接着（没有空格）是一个等号，等号之后是 一串用引号引起的字符串，字符串的内容要赋值给 name。我们定义了别名之后， 这个命令别名可以使用在任何地方。


删除别名，使用 unalias 命令，像这样：

[me@linuxbox ~]$ unalias foo
[me@linuxbox ~]$ type foo
bash: type: foo: not found

在命令行中定义别名有点个小问题。当你的 shell 会话结束时，它们会消失。
```

## 重定向

与 Unix 主题“任何东西都是一个文件”保持一致，像 ls这样的程序实际上把他们的运行结果 输送到一个叫做标准输出的特殊文件（经常用 stdout 表示），而它们的状态信息则送到另一个 叫做标准错误输出的文件（stderr）。默认情况下，标准输出和标准错误输出都连接到屏幕，而不是 保存到磁盘文件。除此之外，许多程序从一个叫做标准输入（stdin）的设备得到输入，默认情况下， 标准输入连接到键盘。

I/O 重定向允许我们更改输出地点和输入来源。一般来说，输入来自键盘，输出送到屏幕， 但是通过 I/O 重定向，我们可以做出改变。

### >的使用



I/O 重定向允许我们来重定义标准输出的地点。我们使用 “>” 重定向符后接文件名将标准输出重定向到除屏幕 以外的另一个文件。为什么我们要这样做呢？因为有时候把一个命令的运行结果存储到 一个文件很有用处。

现在，重复我们的重定向测试，但这次有改动。我们把目录换成一个不存在的目录。

```
[me@linuxbox ~]$ ls -l /bin/usr > ls-output.txt
ls: cannot access /bin/usr: No such file or directory
```

我们收到一个错误信息。这讲得通，因为我们指定了一个不存在的目录 /bin/usr ， 但是为什么这条错误信息显示在屏幕上而不是被重定向到文件 ls-output.txt？答案是， ls 程序不把它的错误信息输送到标准输出。像许多写得正规的 Unix 程序，ls 会把 错误信息送到标准错误输出。因为我们只是重定向了标准输出，而没有重定向标准错误输出， 所以错误信息被送到屏幕。

文件长度为零！这是因为，当我们使用 “>” 重定向符来重定向输出结果时，**目标文件总是从开头被重写**。 因为我们 ls 命令没有产生运行结果，只有错误信息，重定向操作开始重写文件，然后 由于错误而停止，导致文件内容清空。事实上，如果我们需要清空一个文件内容（或者创建一个 新的空文件），可以使用这样的技巧：

```
[me@linuxbox ~]$ > ls-output.txt
```

简单地使用重定向符，没有命令在它之前，这会清空一个已存在文件的内容或是 创建一个新的空文件。

### >>的使用

使用”>>“操作符，将导致输出结果添加到文件内容之后。如果文件不存在，文件会 被创建，就如使用了”>”操作符。

### 标准错误输出重定向

标准错误输出重定向没有专用的重定向操作符。为了重定向标准错误输出，我们必须用到其文件描述符。 一个程序的输出会流入到几个带编号的文件中。这些文件的前 三个称作标准输入、标准输出和标准错误输出，shell 内部分别将其称为文件描述符0、1和2。shell 使用文件描述符提供 了一种表示法来重定向文件。因为标准错误输出和文件描述符2一样，我们用这种 表示法来重定向标准错误输出：

```
[me@linuxbox ~]$ ls -l /bin/usr 2> ls-error.txt
```

### 重定向标准输出和错误到同一个文件

```
[me@linuxbox ~]$ ls -l /bin/usr &> ls-output.txt
```

在这个例子里面，我们使用单单一个表示法 &> 来重定向标准输出和错误到文件 ls-output.txt。

### 处理不需要的输出

我们不想要一个命令的输出结果，只想把它们扔掉。这种情况 尤其适用于错误和状态信息。具体做法是重定向输出结果到一个叫做”/dev/null”的特殊文件。这个文件是系统设备，叫做数字存储桶，它可以 接受输入，并且对输入不做任何处理。为了丢掉命令错误信息，我们这样做：

```
[me@linuxbox ~]$ ls -l /bin/usr 2> /dev/null
```



### cat -- 连接文件

在大多数情况下，你可以认为 cat 命令相似于 DOS 中的 TYPE 命令。你可以使用 cat 来显示 文件而没有分页，例如：

```
[me@linuxbox ~]$ cat ls-output.txt
```

将会显示文件 ls-output.txt 的内容。cat 经常被用来显示简短的文本文件。因为 cat 可以 接受不只一个文件作为参数，所以它也可以用来把文件连接在一起。比方说我们下载了一个 大型文件，这个文件被分离成多个部分（USENET 中的多媒体文件经常以这种方式分离）， 我们想把它们连起来。

```
cat movie.mpeg.0* > movie.mpeg

通配符总是以有序的方式展开
```

如果 cat 没有给出任何参数，它会从标准输入读入数据，又因为标准输入默认情况下连接到键盘， 它正在等待我们输入数据！在输入结束后输入ctrl-d，来告诉 cat，在标准输入中， 它已经到达文件末尾（EOF）。



### 重定向标准输入

使用“<”重定向操作符，我们把标准输入源从键盘改到文件 lazy_dog.txt。

```
[me@linuxbox ~]$ cat < lazy_dog.txt
The quick brown fox jumped over the lazy dog.
```

### 管道线

命令从标准输入读取数据并输送到标准输出的能力被一个称为管道线的 shell 功能所利用。 使用管道操作符”|”（竖杠），一个命令的标准输出可以通过管道送至另一个命令的标准输入：

```
command1 | command2
```

管道线经常用来对数据完成复杂的操作。有可能会把几个命令放在一起组成一个管道线。 通常，以这种方式使用的命令被称为过滤器。过滤器接受输入，以某种方式改变它，然后 输出它。第一个我们想试验的过滤器是 sort。想象一下，我们想把目录/bin 和/usr/bin 中 的可执行程序都联合在一起，再把它们排序，然后浏览执行结果：

```
[me@linuxbox ~]$ ls /bin /usr/bin | sort | uniq | less
```

### uniq - 报道或者忽略重复行

uniq 命令经常和 sort 命令结合在一起使用。uniq 从标准输入或单个文件名参数接受数据有序 列表

默认情况下，从数据列表中删除任何重复行。所以，为了确信 我们的列表中不包含重复句子（这是说，出现在目录/bin 和/usr/bin 中重名的程序），我们添加 uniq 到我们的管道线中：

```
[me@linuxbox ~]$ ls /bin /usr/bin | sort | uniq | less
```

如果我们想看到 重复内容，让 uniq 命令带上”-d”选项

uniq只去重相邻的重复行，所以要首先sort一下再用uniq

### wc － 打印行数、字数和字节数

wc（字数统计）命令是用来显示文件所包含的行数、字数和字节数。例如：

添加 wc 到管道线来统计数据，是个很便利的方法。查看我们的有序列表中程序个数， 我们可以这样做：

```
[me@linuxbox ~]$ ls /bin /usr/bin | sort | uniq | wc -l
2728
```

### grep － 打印匹配行

当 grep 遇到一个文件中的匹配”模式”，它会打印出包含这个类型的行。

比如说，我们想在我们的程序列表中，找到文件名中包含单词”zip”的所有文件。这样一个搜索， 可能让我们了解系统中的一些程序与文件压缩有关系。这样做：

```
[me@linuxbox ~]$ ls /bin /usr/bin | sort | uniq | grep zip
bunzip2
bzip2
gunzip
...
```

grep 有一些方便的选项：

- ”-i”使得 grep 在执行搜索时忽略大小写（通常，搜索是大小写 敏感的）
- ”-v”选项会告诉 grep 只打印不匹配的行。

### head / tail － 打印文件开头部分/结尾部分

head 命令打印文件的前十行，而 tail 命令打印文件的后十行。默认情况下，两个命令 都打印十行文本，但是可以通过”-n”选项来调整命令打印的行数。

tail 有一个选项允许你实时地浏览文件。当观察日志文件的进展时，这很有用。tail 有一个选项允许你实时地浏览文件。当观察日志文件的进展时，这很有用

### tee － 从 Stdin 读取数据，并同时输出到 Stdout 和文件

个命令制造了 一个”tee”（三通管件，做水管工人会对这个非常熟悉），安装到我们的管道上。tee 程序从标准输入读入数据，并且同时复制数据 到标准输出（允许数据继续随着管道线流动）和一个或多个文件。

```
[me@linuxbox ~]$ ls /usr/bin | tee ls.txt | grep zip
bunzip2
bzip2
....


 这次包含 tee 命令，在 grep 过滤管道线的内容之前，来捕捉整个目录列表到文件 ls.txt：
```

## 从Shell的眼中看世界

### 字符展开

通过展开， 你输入的字符，在 shell 对它起作用之前，会展开成为别的字符

```bash
20fu@w20fu-VirtualBox:~$ echo *
Desktop Documents Downloads Music OSLearning ostep-homework Pictures Public riscv-gnu-toolchain shellLearning snap Templates Videos 下载
```

shell 在 echo 命 令被执行前把”*“展开成了另外的东西（在这里，就是在当前工作目录下的文件名字）。 当回车键被按下时，shell 在命令被执行前在命令行上自动展开任何符合条件的字符， 所以 echo 命令的实际参数并不是”*“，而是它展开后的结果。

### 路径名展开

通配符所依赖的工作机制叫做路径名展开。

查看家目录之外的目录：

```
[me@linuxbox ~]$ echo /usr/*/share
/usr/kerberos/share  /usr/local/share
```

### 波浪线展开

如果有用户”foo”这个帐号，那么：

```
[me@linuxbox ~]$ echo ~foo
/home/foo
```

当它用在 一个单词的开头时，它会展开成指定用户的家目录名，如果没有指定用户名，则展开成当前用户的家目录

### 算术表达式展开

shell 在展开中执行算数表达式。这允许我们把 shell 当作计算器来使用：

```
$((expression))
```

算术表达式只支持整数（全部是数字，不带小数点）

### 花括号展开

花括号展开模式可能包含一个开头部分叫做前言，一个结尾部分叫做附言。花括号表达式本身可 能包含一个由逗号分开的字符串列表，或者一个整数区间，或者单个的字符的区间。这种模式不能 嵌入空白字符。这个例子中使用了一个整数区间：

```
[me@linuxbox ~]$ echo Number_{1..5}
Number_1  Number_2  Number_3  Number_4  Number_5
```

### 命令替换

命令替换允许我们把一个命令的输出作为另一个命令的一部分来使用：

```
[me@linuxbox ~]$ ls -l $(which cp)
-rwxr-xr-x 1 root root 71516 2007-12-05 08:58 /bin/cp
```

```
[me@linuxbox ~]$ file $(ls /usr/bin/* | grep zip)
/usr/bin/bunzip2:     symbolic link to `bzip2'
....
```

### 引用

```
[me@linuxbox ~]$ echo this is a    test
this is a test

[me@linuxbox ~]$ echo The total is $100.00
The total is 00.00
```

在第一个例子中，shell 利用**单词分割**删除掉 echo 命令的参数列表中多余的空格。在第二个例子中， 参数展开把 `$1` 的值替换为一个空字符串，因为 `1` 是没有定义的变量。shell 提供了一种 叫做引用的机制，来有选择地禁止不需要的展开。

单词分割机制：

在默认情况下，单词分割机制会在单词中寻找空格，制表符，和换行符，并把它们看作 单词之间的界定符。这意味着无引用的空格，**制表符和换行符都不是文本的一部分， 它们只作为分隔符使用。由于它们把单词分为不同的参数**

#### 双引号引用

双引号。如果你把文本放在双引号中， shell 使用的特殊字符，都失去它们的特殊含义，被当作普通字符来看待。 有几个例外： $，\ (反斜杠），和 `（倒引号）。这意味着单词分割、路径名展开、 波浪线展开和花括号展开都将失效，然而参数展开、算术展开和命令替换 仍然执行。使用双引号，我们可以处理包含空格的文件名。

比方说 *two words.txt* 文件，如果我们试图在命令行中使用这个 文件，单词分割机制会导致这个文件名被看作两个独自的参数，而不是所期望 的单个参数：

```
[me@linuxbox ~]$ ls -l two words.txt
ls: cannot access two: No such file or directory
ls: cannot access words.txt: No such file or directory
```

使用双引号，我们可以阻止单词分割，得到期望的结果；进一步，我们甚至可以修复 破损的文件名

```
[me@linuxbox ~]$ ls -l "two words.txt"
-rw-rw-r-- 1 me   me   18 2008-02-20 13:03 two words.txt
[me@linuxbox ~]$ mv "two words.txt" two_words.txt
```

在文件命名的时候多使用下划线而不是空格能够减少双引号的使用

### 单引号

如果需要禁止所有的展开，我们要使用单引号。

### 转义字符

有时候我们只想引用单个字符。我们可以在字符之前加上一个反斜杠，在这里叫做转义字符。 经常在双引号中使用转义字符，来有选择地阻止展开。

```
[me@linuxbox ~]$ echo "The balance for user $USER is: \$5.00"
The balance for user me is: $5.00
```

## 键盘操作高级技巧

| 按键   | 行动                                                   |
| :----- | :----------------------------------------------------- |
| Ctrl-a | 移动光标到行首。                                       |
| Ctrl-e | 移动光标到行尾。                                       |
| Ctrl-f | 光标前移一个字符；和右箭头作用一样。                   |
| Ctrl-b | 光标后移一个字符；和左箭头作用一样。                   |
| Alt-f  | 光标前移一个字。                                       |
| Alt-b  | 光标后移一个字。                                       |
| Ctrl-l | 清空屏幕，移动光标到左上角。clear 命令完成同样的工作。 |

| Ctrl-d | 删除光标位置的字符。 |
| ------ | -------------------- |
|        |                      |

Readline 的文档使用术语 killing 和 yanking 来指我们平常所说的剪切和粘贴。 剪切下来的本文被存储在一个叫做剪切环(kill-ring)的缓冲区中。

| 按键          | 行动                                                         |
| :------------ | :----------------------------------------------------------- |
| Ctrl-k        | 剪切从光标位置到行尾的文本。                                 |
| Ctrl-u        | 剪切从光标位置到行首的文本。                                 |
| Alt-d         | 剪切从光标位置到词尾的文本。                                 |
| Alt-Backspace | 剪切从光标位置到词头的文本。如果光标在一个单词的开头，剪切前一个单词。 |
| Ctrl-y        | 把剪切环中的文本粘贴到光标位置。                             |

## 权限

在 Unix 安全模型中，一个用户可能拥有文件和目录。当一个用户拥有一个文件或目录时， 用户对这个文件或目录的访问权限拥有控制权。用户反过来又属于一个由一个或多个 用户组成的用户组，用户组成员由文件和目录的所有者授予对文件和目录的访问权限。除了 对一个用户组授予权限之外，文件所有者可能会给所有的人授权，**在 Unix 术语中，”所有的人“ 也被称作“整个世界”（ world ）**。可以用 id 命令，来找到关于你自己身份的信息：

```
[me@linuxbox ~]$ id
uid=500(me) gid=500(me) groups=500(me)
```

让我们看一下输出结果。当用户创建帐户之后，系统会给用户分配一个号码，叫做用户 ID 或者 uid，然后，为了符合人类的习惯，这个 ID 映射到一个用户名。系统又会给这个用户 分配一个原始的组 ID(即 gid)。一个用户可以属于多个组。上面的例子来自于 Fedora 系统， 下面 Ubuntu 的输出结果看起来有点儿不同：

```
[me@linuxbox ~]$ id
uid=1000(me) gid=1000(me)
groups=4(adm),20(dialout),24(cdrom),25(floppy),29(audio),30(dip),44(v
ideo),46(plugdev),108(lpadmin),114(admin),1000(me)
```

正如我们能看到的，两个系统中用户的 uid 和 gid 号码是不同的。原因很简单，因为 Fedora 系统 从500开始进行普通用户帐户的编号，而 Ubuntu 从1000开始。我们也能看到 Ubuntu 的用户属于 更多的用户组。这和 Ubuntu 管理系统设备和服务权限的方式有关系。

那么这些信息存在哪里呢？像 Linux 系统中的许多东西一样，存到了一系列的文本文件。用户帐户 定义在 /etc/passwd 文件里面，用户组定义在 /etc/group 文件里面。当用户帐户和用户组创建以后， 这些文件随着文件 /etc/shadow 的变动而修改，文件 /etc/shadow 包含了关于用户密码的信息。 对于每个用户帐号，文件 /etc/passwd 定义了用户（登录）名、uid、gid、帐号的真实姓名、家目录 和登录 shell。如果你查看一下文件 /etc/passwd 和文件 /etc/group 的内容，你会注意到除了普通 用户帐号之外，还有超级用户（uid 0）帐号，和各种各样的系统用户。

### 读取、写入和执行

对于文件和目录的访问权力是根据”读权限“、”写权限“和“执行权限“来定义的。

```
[me@linuxbox ~]$ > foo.txt
[me@linuxbox ~]$ ls -l foo.txt
-rw-rw-r-- 1 me   me   0 2008-03-06 14:52 foo.txt
```

列表的前十个字符是文件的属性。这十个字符的第一个字符表明文件类型。下表是你可能经常看到 的文件类型（还有其它的，不常见类型）

| 属性 | 文件类型                                                     |
| :--- | :----------------------------------------------------------- |
| -    | 一个普通文件                                                 |
| d    | 一个目录                                                     |
| l    | 一个符号链接。注意对于符号链接文件，剩余的文件属性总是"rwxrwxrwx"，而且都是 虚拟值。真正的文件属性是指符号链接所指向的文件的属性。 |
| c    | 一个字符设备文件。这种文件类型是指按照字节流来处理数据的设备。 比如说终端机或者调制解调器 |
| b    | 一个块设备文件。这种文件类型是指按照数据块来处理数据的设备，例如一个硬盘或者 CD-ROM 盘。 |

剩下的九个字符叫做文件模式，代表着文件所有者、文件组所有者和其他人的读、写和执行权限。

![image-20211009174449481](Shell%E5%AD%A6%E4%B9%A0.assets/image-20211009174449481.png)

当设置文件模式后，r、w和x 模式属性对文件和目录会产生以下影响：

| 属性 | 文件                                                         | 目录                                                         |
| :--- | :----------------------------------------------------------- | :----------------------------------------------------------- |
| r    | 允许打开并读取文件内容。                                     | 允许列出目录中的内容，前提是目录必须设置了可执行属性（x）。  |
| w    | 允许写入文件内容或截断文件。但是不允许对文件进行重命名或删除，重命名或删除是由目录的属性决定的。 | 允许在目录下新建、删除或重命名文件，前提是目录必须设置了可执行属性（x）。 |
| x    | 允许将文件作为程序来执行，使用脚本语言编写的程序必须设置为可读才能被执行。 | 允许进入目录，例如：cd directory 。                          |

| lrwxrwxrwx | 一个符号链接，符号链接的权限都是虚拟的，真实的权限应该以符号链接指向的文件为准。 |
| ---------- | ------------------------------------------------------------ |
| drwxrwx--- | 一个目录，文件所有者以及文件所有者的组成员可以访问该目录，并且可以在该目录下新建、重命名、删除文件。 |
| drwxr-x--- | 一个目录，文件所有者可以访问该目录，并且可以在该目录下新建、重命名、删除文件，文件所有者的组成员可以访问该目录，但是不能新建、重命名、删除文件。 |

### chmod － 更改文件模式

更改文件或目录的模式（权限），可以利用 chmod 命令。注意只有文件的所有者或者超级用户才 能更改文件或目录的模式。chmod 命令支持两种不同的方法来改变文件模式：八进制数字表示法或 符号表示法。首先我们讨论一下八进制数字表示法。

通过八进制表示法，我们使用八进制数字来设置所期望的权限模式。因为每个八进制数字代表了 3个二进制数字，这种对应关系，正好映射到用来存储文件模式所使用的方案上。下表展示了 我们所要表达的意思：

| Octal | Binary | File Mode |
| ----- | ------ | --------- |
| 0     | 000    | ---       |
| 1     | 001    | --x       |
| 2     | 010    | -w-       |
| 3     | 011    | -wx       |
| 4     | 100    | r--       |
| 5     | 101    | r-x       |
| 6     | 110    | rw-       |
| 7     | 111    | rwx       |

通过使用3个八进制数字，我们能够设置文件所有者、用户组和其他人的权限：

```
[me@linuxbox ~]$ > foo.txt
[me@linuxbox ~]$ ls -l foo.txt
-rw-rw-r-- 1 me    me    0  2008-03-06 14:52 foo.txt
[me@linuxbox ~]$ chmod 600 foo.txt
[me@linuxbox ~]$ ls -l foo.txt
-rw------- 1 me    me    0  2008-03-06 14:52 foo.txt
```

通常只会用到一些常见的映射关系： 7 (rwx)，6 (rw-)，5 (r-x)，4 (r--)，和 0 (---)。

chmod 命令支持一种符号表示法，来指定文件模式。符号表示法分为三部分：更改会影响谁， 要执行哪个操作，要设置哪种权限。通过字符 “u”、“g”、“o”和 “a” 的组合来指定 要影响的对象，如下所示：

| u    | "user"的简写，意思是文件或目录的所有者。 |
| ---- | ---------------------------------------- |
| g    | 用户组。                                 |
| o    | "others"的简写，意思是其他所有的人。     |
| a    | "all"的简写，是"u", "g"和“o”三者的联合。 |

如果没有指定字符，则假定使用”all”。执行的操作可能是一个“＋”字符，表示加上一个权限， 一个“－”，表示删掉一个权限，或者是一个“＝”，表示只有指定的权限可用，其它所有的权限被删除。

| u+x       | 为文件所有者添加可执行权限。                                 |
| --------- | ------------------------------------------------------------ |
| u-x       | 删除文件所有者的可执行权限。                                 |
| +x        | 为文件所有者，用户组，和其他所有人添加可执行权限。 等价于 a+x。 |
| o-rw      | 除了文件所有者和用户组，删除其他人的读权限和写权限。         |
| go=rw     | 给文件所属的组和文件所属者/组以外的人读写权限。如果文件所属组或其他人已经拥有执行的权限，执行权限将被移除。 |
| u+x,go=rw | 给文件拥有者执行权限并给组和其他人读和执行的权限。多种设定可以用逗号分开。 |

### umask － 设置默认权限

当创建一个文件时，umask 命令控制着文件的默认权限。umask 命令使用八进制表示法来表达 从文件模式属性中删除一个位掩码。大家看下面的例子：

```
[me@linuxbox ~]$ rm -f foo.txt
[me@linuxbox ~]$ umask
0002
[me@linuxbox ~]$ > foo.txt
[me@linuxbox ~]$ ls -l foo.txt
-rw-rw-r-- 1 me   me   0 2008-03-06 14:53 foo.txt
```

注意掩码中若出现一个数字1，则 删除文件模式中和这个1在相同位置的权限，在这是其他人的写权限。这就是掩码要完成的 任务。掩码的二进制形式中，出现数字1的位置，相应地关掉一个文件模式属性。看一下 掩码0022的作用：

| Original file mode | --- rw- rw- rw- |
| ------------------ | --------------- |
| Mask               | 000 000 010 010 |
| Result             | --- rw- r-- r-- |

### 更改身份

有三种方式，可以拥有多重身份：

1. 注销系统并以其他用户身份重新登录系统。
2. 使用 su 命令。
3. 使用 sudo 命令

#### su － 以其他用户身份和组 ID 运行一个 shell

su 命令用来以另一个用户的身份来启动 shell。这个命令语法看起来像这样：

```
su [-[l]] [user]
```

如果包含”-l”选项，那么会为指定用户启动一个需要登录的 shell。这意味着会加载此用户的 shell 环境， 并且工作目录会更改到这个用户的家目录。这通常是我们所需要的。如果不指定用户，那么就假定是 超级用户。注意（不可思议地），选项”-l”可以缩写为”-“，这是经常用到的形式。启动超级用户的 shell， 我们可以这样做：

```
[me@linuxbox ~]$ su -
Password:
[root@linuxbox ~]#
```

按下回车符之后，shell 提示我们输入超级用户的密码。如果密码输入正确，出现一个新的 shell 提示符， 这表明这个 shell 具有超级用户特权（提示符的末尾字符是”#”而不是”$”），并且当前工作目录是超级用户的家目录 （通常是/root）。一旦进入一个新的 shell，我们能执行超级用户所使用的命令。当工作完成后， 输入”exit”，则返回到原来的 shell:

```
[root@linuxbox ~]# exit
[me@linuxbox ~]$
```



```
Ubuntu的默认root密码是随机的，即每次开机都有一个新的root密码。 我们可以在终端输入命令sudo passwd，然后输入当前用户的密码，enter，终端会提示我们输入新的密码并确认，此时的密码就是root新密码。
```





以这样的方式使用 su 命令，也可以只执行单个命令，而不是启动一个新的可交互的 shell：

```
su -c 'command'
```

Using this form, a single command line is passed to the new shell for execution. It is important to enclose the command in quotes, as we do not want expansion to occur in our shell, but rather in the new shell:

使用这种模式，命令传递到一个新 shell 中执行。把命令用单引号引起来很重要，因为我们不想 命令在我们的 shell 中展开，但需要在新 shell 中展开。

```
[me@linuxbox ~]$ su -c 'ls -l /root/*'
Password:
-rw------- 1 root root    754 2007-08-11 03:19 /root/anaconda-ks.cfg

/root/Mail:
total 0
[me@linuxbox ~]$
```

#### sudo － 以另一个用户身份执行命令

sudo 命令不要求超级用户的密码。使用 sudo 命令时，用户使用他/她自己的密码 来认证。

su 和 sudo 之间的一个重要区别是 sudo 不会重新启动一个 shell，也不会加载另一个 用户的 shell 运行环境。这意味者命令不必用单引号引起来。

### chown － 更改文件所有者和用户组

chown 可以根据这个命令的第一个参数更改文件所有者和/或文件用户组。这里有 一些例子：

| 参数      | 结果                                                         |
| :-------- | :----------------------------------------------------------- |
| bob       | 把文件所有者从当前属主更改为用户 bob。                       |
| bob:users | 把文件所有者改为用户 bob，文件用户组改为用户组 users。       |
| :admins   | 把文件用户组改为组 admins，文件所有者不变。                  |
| bob:      | 文件所有者改为用户 bob，文件用户组改为用户 bob 登录系统时所属的用户组。<br /> |

比方说，我们有两个用户，janet 拥有超级用户访问权限，而 tony 没有。用户 janet 想要从 她的家目录复制一个文件到用户 tony 的家目录。因为用户 janet 想要 tony 能够编辑这个文件， janet 把这个文件的所有者更改为 tony:

```
[janet@linuxbox ~]$ sudo cp myfile.txt ~tony
Password:
[janet@linuxbox ~]$ sudo ls -l ~tony/myfile.txt
-rw-r--r-- 1 root  root 8031 2008-03-20 14:30 /home/tony/myfile.txt
[janet@linuxbox ~]$ sudo chown tony: ~tony/myfile.txt
[janet@linuxbox ~]$ sudo ls -l ~tony/myfile.txt
-rw-r--r-- 1 tony  tony 8031 2008-03-20 14:30 /home/tony/myfile.txt
```

### 密码修改

使用 passwd 命令，来设置或更改用户密码。命令语法如下所示：

```
passwd [user]
```

To change your password, just enter the passwd command. You will be prompted for your old password and your new password:

只要输入 passwd 命令，就能更改你的密码。shell 会提示你输入你的旧密码和你的新密码：

```
[me@linuxbox ~]$ passwd
(current) UNIX password:
New UNIX password:
```

## 进程

从进程的角度而言，一个程序启动另一个程序可以被表述为一个父进程可以产生一个子进程。

系统分配给每个进程一个数字，这个数字叫做 进程(process) ID 或 PID。PID 号按升序分配，init 进程的 PID 总是1。

### 查看进程

查看进程，最常使用地命令（有几个命令）是 ps(process status)。ps 程序有许多选项，它最简单地使用形式是这样的：

```
[me@linuxbox ~]$ ps
PID TTY           TIME CMD
5198 pts/1    00:00:00 bash
10129 pts/1   00:00:00 ps
```

默认情况下，ps 不会显示很多进程信息，只是列出与当前终端会话相关的进程。

们先看一下 ps 命令运行结果的其它字段。 TTY 是 “Teletype”(直译电传打字机) 的简写，是指进程的控制终端。TTY 体现了 Unix 的年代久远。TIME 字段表示 进程所消耗的 CPU 时间数量。

加上 “x” 选项（注意没有开头的 “-“ 字符），告诉 ps 命令，展示所有进程，不管它们由什么 终端（如果有的话）控制。在 TTY 一栏中出现的 “?” ，表示没有控制终端。使用这个 “x” 选项，可以 看到我们所拥有的每个进程的信息。

STAT 是 “state” 的简写，它揭示了进程当前状态

| 状态 | 含义                                                         |
| :--- | :----------------------------------------------------------- |
| R    | 运行中。这意味着，进程正在运行或准备运行。                   |
| S    | 正在睡眠。进程没有运行，而是，正在等待一个事件， 比如说，一个按键或者网络分组。 |
| D    | 不可中断睡眠。进程正在等待 I/O，比方说，一个磁盘驱动器的 I/O。 |
| T    | 已停止. 已经指示进程停止运行。稍后介绍更多。                 |
| Z    | 一个死进程或“僵尸”进程。这是一个已经终止的子进程，但是它的父进程还没有清空它。 （父进程没有把子进程从进程表中删除） |
| <    | 一个高优先级进程。这可能会授予一个进程更多重要的资源，给它更多的 CPU 时间。 进程的这种属性叫做 niceness。具有高优先级的进程据说是不好的（less nice）， 因为它占用了比较多的 CPU 时间，这样就给其它进程留下很少时间。 |
| N    | 低优先级进程。 一个低优先级进程，只有当其它高优先级进程被服务了之后，才会得到处理器时间。 |

进程状态信息之后，可能还跟随其他的字符，来表示各种外来进程的特性。详细信息请看 ps 手册页。

一个流行的选项组合是 “aux”（不带开头的”-“字符）。这会给我们更多信息：

| USER  | 用户 ID. 进程的所有者。                          |
| ----- | ------------------------------------------------ |
| %CPU  | 以百分比表示的 CPU 使用率                        |
| %MEM  | 以百分比表示的内存使用率                         |
| VSZ   | 虚拟内存大小                                     |
| RSS   | 进程占用的物理内存的大小，以千字节为单位。       |
| START | 进程启动的时间。若它的值超过24小时，则用天表示。 |

### 用 top 命令动态查看进程

top 程序以进程活动顺序显示连续更新的系统进程列表。（默认情况下，每三秒钟更新一次），”top”这个名字 来源于 top 程序是用来查看系统中“顶端”进程的。top 显示结果由两部分组成： 最上面是系统概要，下面是进程列表，以 CPU 的使用率排序

```
top - 14:59:20 up 6:30, 2 users, load average: 0.07, 0.02, 0.00
Tasks: 109 total,   1 running,  106 sleeping,    0 stopped,    2 zombie
Cpu(s): 0.7%us, 1.0%sy, 0.0%ni, 98.3%id, 0.0%wa, 0.0%hi, 0.0%si
Mem:   319496k total,   314860k used,   4636k free,   19392k buff
Swap:  875500k total,   149128k used,   726372k free,  114676k cach

 PID  USER       PR   NI   VIRT   RES   SHR  S %CPU  %MEM   TIME+    COMMAND
6244  me         39   19  31752  3124  2188  S  6.3   1.0   16:24.42 trackerd
....
```

| 行号 | 字段          | 意义                                                         |
| :--- | :------------ | :----------------------------------------------------------- |
| 1    | top           | 程序名。                                                     |
|      | 14:59:20      | 当前时间。                                                   |
|      | up 6:30       | 这是正常运行时间。它是计算机从上次启动到现在所运行的时间。 在这个例子里，系统已经运行了六个半小时。 |
|      | 2 users       | 有两个用户登录系统。                                         |
|      | load average: | 加载平均值是指，等待运行的进程数目，也就是说，处于可以运行状态并共享 CPU 的进程个数。 这里展示了三个数值，每个数值对应不同的时间段。第一个是最后60秒的平均值， 下一个是前5分钟的平均值，最后一个是前15分钟的平均值。若平均值低于1.0，则指示计算机 工作不忙碌。 |
| 2    | Tasks:        | 总结了进程数目和这些进程的各种状态。                         |
| 3    | Cpu(s):       | 这一行描述了 CPU 正在进行的活动的特性。                      |
|      | 0.7%us        | 0.7% 的 CPU 被用于用户进程。这意味着进程在内核之外。         |
|      | 1.0%sy        | 1.0%的 CPU 时间被用于系统（内核）进程。                      |
|      | 0.0%ni        | 0.0%的 CPU 时间被用于低优先级进程。                          |
|      | 98.3%id       | 98.3%的 CPU 时间是空闲的。                                   |
|      | 0.0%wa        | 0.0%的 CPU 时间来等待 I/O。                                  |
| 4    | Mem:          | 展示物理内存的使用情况。                                     |
| 5    | Swap:         | 展示交换分区（虚拟内存）的使用情况。                         |

### 操作进程

在一个终端中，输入 Ctrl-c，中断一个程序。

为了启动一个程序并让它立即在后台 运行，我们在程序命令之后，加上”&”字符：

```
[me@linuxbox ~]$ xlogo &
[1] 28236
[me@linuxbox ~]$
```

shell 的任务控制功能给出了一种列出从我们终端中启动了的任务的方法。执行 jobs 命令，我们可以看到这个输出列表：

```
[me@linuxbox ~]$ jobs
[1]+ Running            xlogo &
```

一个在后台运行的进程对一切来自键盘的输入都免疫，也不能用 Ctrl-c 来中断它。 为了让一个进程返回前台 (foreground)，这样使用 fg 命令

```
[me@linuxbox ~]$ jobs
[1]+ Running        xlogo &
[me@linuxbox ~]$ fg %1
xlogo
```

我们想要停下一个进程，而不是终止它。我们这么做通常是为了允许前台进程被移动到后台。 输入 Ctrl-z，可以停下一个前台进程。

```
[me@linuxbox ~]$ xlogo
[1]+ Stopped                 xlogo
[me@linuxbox ~]$
```

使用 fg 命令，可以恢复程序到前台运行，或者用 bg 命令把程序移到后台。
