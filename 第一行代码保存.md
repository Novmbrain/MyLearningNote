# 第一行代码

[TOC]



## 2. Activity

代码和XML中文件引用格式

- 在代码中通过 R.string.app_name 可以获得该字符串的引用(res目录下资源的引用)。 

- 在 XML 中通过@string/app_name 可以获得该字符串的引用。

- 如果 你需要在 XML 中引用一个 id，就使用@id/id_name 这种语法，而如果你需要在 XML 中定义一 个 id，则要使用@+id/id_name 这种语法

### 2.1  活动的基本用法

#### Activity创建过程

1. 在Layout层创建Layout resource file进行UI设计

2. 在活动中加载对应的布局

   setContentView(R.layout.first_layout);

   调用了 setContentView()方法来给当前的活动加载一个布局，而在 setContentView()方法中，我们一般都会传入一个布局文件的 id。

3. 在 AndroidManifest.xml 中进行注册Activity

   ```xml
   <application
                android:allowBackup="true"
                android:icon="@mipmap/ic_launcher"
                android:label="@string/app_name"
                android:roundIcon="@mipmap/ic_launcher_round"
                android:supportsRtl="true"
                android:theme="@style/Theme.ActivityTest">
       <activity android:name=".FirstActivity" 
                 android:label="This is FirstActivity">
           <intent-filter>
               <action android:name="android.intent.action.MAIN"/>
               <category android:name="android.intent.category.LAUNCHER"/>
           </intent-filter>
       </activity>
   </application>
   
   <!--.FirstActivity 是什么意思呢？其实这不过就是 com.example.activitytest.FirstActivity
   的缩写而已。由于在最外层<manifest>标签中已经通过 package 属性指定了程序的包名是
   com.example.activitytest，因此在注册活动时这一部分就可以省略了，直接使用.FirstActivity 就足够了。-->
   ```

   

4. 在Android Manifest.xml中选择一个Activity配置为主活动

   ```xml
   <application
                ...>
       <activity android:name=".FirstActivity"
                 android:label="This is FirstActivity">
           <intent-filter>
               <action android:name="android.intent.action.MAIN"/>
               <category android:name="android.intent.category.LAUNCHER"/>
           </intent-filter>
       </activity>
   </application>
   
   android:label 指定活动中标题栏的内容，标题栏是显示在活动最顶部的
   给主活动指定的 label 不仅会成为标题栏中的内容，还会成为启动器（Launcher）中应用程序显示的名称。
   
   ```

 #### 在活动中使用Toast

   Toast 是 Android 系统提供的一种非常好的提醒方式，在程序中可以使用它将一些短小的信息 通知给用户，这些信息会在一段时间后自动消失，并且不会占用任何屏幕空间

```java
@Override
protected void onCreate(Bundle savedInstanceState) {
    super.onCreate(savedInstanceState);
    setContentView(R.layout.first_layout);

    Button button1 = (Button) findViewById(R.id.button_1);
    button1.setOnClickListener(new View.OnClickListener() {
        @Override
        public void onClick(View v) {
            Toast.makeText(FirstActivity.this, "You clicked Button 1",
                           Toast.LENGTH_SHORT).show();
        }
    });
}

findViewById()方法获取到在布局文件中定义的元素，这里我们传入R.id.button_1，来得到按钮的实例，这个值是刚才在 first_layout.xml 中通过 android:id 属性指定的。findViewById()方法返回的是一个 View 对象，我们需要向下转型将它转成 Button 对象

    调用 setOnClickListener()方法为按钮注册一个监听器，点击按钮时就会执行监听器中的 onClick()方法

    Toast 的用法非常简单，通过静态方法 makeText()创建出一个 Toast 对象，然后调用 show()将 Toast 显示出来就可以了。这里需要注意的是，makeText()方法需要传入 3 个参数。第一个参数是 Context，也就是 Toast 要求的上下文，由于活动本身就是一个 Context 对象，因此这里直接传入 FirstActivity.this 即可。第二个参数是 Toast 显示的文本内容，第三个参数是 Toast显示的时长，有两个内置常量可以选择 Toast.LENGTH_SHORT 和 Toast.LENGTH_LONG。
```

#### 在活动中使用Menu

首先在 res 目录下新建一个 menu 文件夹，右击 res 目录→New→Directory，输入文件夹名 menu，点击 OK。接着在这个文件夹下再新建一个名叫 main 的菜单文件，右击 menu 文件夹→ New→Menu resource file，文件名输入 main.

```xml
<menu xmlns:android="http://schemas.android.com/apk/res/android">
    <item
          android:id="@+id/add_item"
          android:title="Add"/>
    <item
          android:id="@+id/remove_item"
          android:title="Remove"/>
</menu>

<item>标签就是用来创建具体的某一个菜单项，然后通过 android:id 给这个菜单项指定一个唯一的标识符，通过 android:title 给这个菜单项指定一个名称。
```

然后在 onCreateOptionsMenu()方法中编写如下代码：

```java
@Override
public boolean onCreateOptionsMenu(Menu menu) {
    getMenuInflater().inflate(R.menu.main, menu);
    return true;
}

通过 getMenuInflater()方法能够得到 MenuInflater 对象，再调用它的 inflate()方法就可以给当前活动创建菜单了。inflate()方法接收两个参数，第一个参数用于指定我们通过哪一个资源文件来创建菜单，这里当然传入 R.menu.main。第二个参数用于指定我们的菜单项将添加到哪一个 Menu 对象当中，这里直接使用 onCreateOptionsMenu()方法中传入的 menu 参数。然后给这个方法返回 true，表示允许创建的菜单显示出来，如果返回了 false，创建的菜单将无法显示。
```

再定义菜单响应事件，重写 onOptionsItemSelected()方法

```java
@Override
public boolean onOptionsItemSelected(MenuItem item) {
    switch (item.getItemId()){
        case R.id.add_item:
            Toast.makeText(this, "You clicked Add", Toast.LENGTH_SHORT).show();
            break;
        case R.id.remove_item:
            Toast.makeText(this, "You clicked Remove", Toast.LENGTH_SHORT).show();
            break;
        default:
    }
    return true;
}
通过调用 item.getItemId()来判断我们点击的是哪一个菜单项
```

#### 销毁一个活动

```java
button1.setOnClickListener(new View.OnClickListener() {
    @Override
    public void onClick(View v) {
        finish();
    }
});

通过Button调用finish()方法销毁一个活动
```





### 2.2 使用Intent在活动之间穿梭

Intent 是 Android 程序中各组件之间进行交互的一种重要方式，它不仅可以指明当前组件想 要执行的动作，还可以在不同组件之间传递数据。Intent 一般可被用于启动活动、启动服务以及发送广播等场景

#### 显式Intent

Intent 有多个构造函数的重载，其中一个是 Intent(Context packageContext, Class cls)。这个构造函数接收两个参数，第一个参数 Context 要求提供一个启动活动的上下文，第 二个参数 Class 则是指定想要启动的目标活动，通过这个构造函数就可以构建出 Intent 的“意 图”。然后我们应该怎么使用这个 Intent呢？Activity 类中提供了一个 startActivity()方法，这 个方法是专门用于启动活动的，它接收一个 Intent 参数，这里我们将构建好的 Intent 传入 startActivity()方法就可以启动目标活动了。

```java
Button button1 = (Button) findViewById(R.id.button_1);
button1.setOnClickListener(new View.OnClickListener() {
    @Override
    public void onClick(View v) {
        Intent intent = new Intent(FirstActivity.this, SecondActivity.class);
        startActivity(intent);
    }
});
```



#### 隐式Intent

相比于显式 Intent，隐式 Intent 则含蓄了许多，它并不明确指出我们想要启动哪一个活动， 而是指定了一系列更为抽象的 action 和 category 等信息，然后交由系统去分析这个 Intent， 并帮我们找出合适的活动去启动。

```xml
<activity android:name=".SecondActivity">
    <intent-filter>
        <action android:name="com.example.activitytest.ACTION_STAR"/>
        <category android:name="android.intent.category.DEFAULT"/>
    </intent-filter>
</activity>

在<action>标签中我们指明了当前活动可以响应 com.example.activitytest.ACTION_START 这个 action，而<category>标签则包含了一些附加信息，更精确地指明了当前的活动能够响应的 Intent 中还可能带有的 category。只有<action>和<category>中的内容同时能够匹配上 Intent 中指定的 action 和 category 时，这个活动才能响应该 Intent
    
    

```

```java
Button button1 = (Button) findViewById(R.id.button_1);
button1.setOnClickListener(new View.OnClickListener() {
    @Override
    public void onClick(View v) {
        Intent intent = new Intent("com.example.activitytest.ACTION_START");
        startActivity(intent);
    }
});

我们使用了 Intent 的另一个构造函数，直接将 action 的字符串传了进去，表明我们想要启动能够响应 com.example.activitytest.ACTION_START 这个 action 的活动。那前面不是说要<action>和<category>同时匹配上才能响应的吗？怎么没看到哪里有指定category 呢？这是因为 android.intent.category.DEFAULT 是一种默认的 category，在调用 startActivity()方法的时候会自动将这个 category 添加到 Intent 中。
```

使用隐式 Intent，我们不仅可以启动自己程序内的活动，还可以启动其他程序的活动，这使 得 Android多个应用程序之间的功能共享成为了可能

```java
@Override
public void onClick(View v) {
    Intent intent = new Intent(Intent.ACTION_VIEW);
    intent.setData(Uri.parse("http://www.google.com"));
    startActivity(intent);
}

这里我们首先指定了 Intent 的 action 是 Intent.ACTION_VIEW，这是一个 Android 系统内置的动作，其常量值为 android.intent.action.VIEW。然后通过 Uri.parse()方法，将一个网址字符串解析成一个 Uri 对象，再调用 Intent 的 setData()方法将这个 Uri 对象传递进去。
```

我们也可以闯进一个新的Activity，让它也能响应打开网页的 Intent。

```xml
<activity android:name=".ThirdActivity">
    <intent-filter>
        <action android:name="android.intent.action.VIEW" />
        <category android:name="android.intent.category.DEFAULT" />
        <data android:scheme="http" />
    </intent-filter>
</activity>
```

除了 http 协议外，我们还可以指定很多其他协议，比如 geo 表示显示地理位置、tel 表示拨打 电话。下面的代码展示了如何在我们的程序中调用系统拨号界面。

```java
button1.setOnClickListener(new View.OnClickListener() {
    @Override
    public void onClick(View v) {
        Intent intent = new Intent(Intent.ACTION_DIAL);
        intent.setData(Uri.parse("tel:10086"));
        startActivity(intent);
    }
});

首先指定了 Intent 的 action 是 Intent.ACTION_DIAL，这又是一个 Android 系统的内置动作。然后在 data 部分指定了协议是 tel，号码是 10086。
```

#### 向下一个活动传递数据

Intent 中提供了一系列 putExtra()方法的重载，可 以把我们想要传递的数据暂存在 Intent 中，启动了另一个活动后，只需要把这些数据再从 Intent 中取出就可以了。

比如说 FirstActivity 中有一个字符串，现在想把这个字符串传递到 SecondActivity 中，你就可以这样编写：

```java
@Override
public void onClick(View v) {
    String data = "Hello SecondActivity";
    Intent intent = new Intent(FirstActivity.this, SecondActivity.class);
    intent.putExtra("extra_data", data);
    startActivity(intent);

}
这里我们还是使用显式 Intent 的方式来启动 SecondActivity，并通过 putExtra()方法传递了一个字符串。注意这里 putExtra()方法接收两个参数，第一个参数是键，用于后面从 Intent 中取值，第二个参数才是真正要传递的数据。
```

同时在SecondActivity中

```java
@Override
protected void onCreate(Bundle savedInstanceState) {
    super.onCreate(savedInstanceState);
    setContentView(R.layout.second_layout);
    Intent intent = getIntent();
    String extra_data = intent.getStringExtra("extra_data");
    Log.d("SecondActivity", extra_data);

}

首先可以通过 getIntent()方法获取到用于启动 SecondActivity 的 Intent，然后调用getStringExtra()方法，传入相应的键值，就可以得到传递的数据了。这里由于我们传递的是字符串，所以使用 getStringExtra()方法来获取传递的数据。如果传递的是整型数据，则使用 getIntExtra()方法；如果传递的是布尔型数据，则使用 getBooleanExtra()方法，以此类推。
```

#### 返回数据给上一个活动

返回上一个活动只需要按一下 Back 键就可以了，并没有一个用于启动活动的 Intent 来传递数据。通过查阅文档你会发现，Activity 中还有一个 startActivityForResult() 方法也是用于启动活动的，但这个方法期望在活动销毁的时候能够返回一个结果给上一个活动。 毫无疑问，这就是我们所需要的。

startActivityForResult()方法接收两个参数，第一个参数还是 Intent，第二个参数是请 求码，用于在之后的回调中判断数据的来源。我们还是来实战一下，修改 FirstActivity 中按钮的 点击事件，

```java
@Override
public void onClick(View v) {
    Intent intent = new Intent(FirstActivity.this, SecondActivity.class);
    startActivityForResult(intent, 1);
}

这里我们使用了 startActivityForResult()方法来启动 SecondActivity，请求码只要是一个唯一值就可以了，这里传入了 1
```

接下来我们在 SecondActivity 中给按钮注册点击事件，并在 点击事件中添加返回数据的逻辑

```java
@Override
protected void onCreate(Bundle savedInstanceState) {
    super.onCreate(savedInstanceState);
    setContentView(R.layout.second_layout);
    Button button2 = (Button) findViewById(R.id.button_2);
    button2.setOnClickListener(new View.OnClickListener() {
        @Override
        public void onClick(View v) {
            Intent intent = new Intent();
            intent.putExtra("data_return", "Hello FirstActivity");
            setResult(RESULT_OK, intent);
            finish();
        }
    });

}
我们还是构建了一个 Intent，只不过这个 Intent 仅仅是用于传递数据而已，它没有指定任何的“意图”。紧接着把要传递的数据存放在 Intent 中，然后调用了 setResult()方法。这个方法非常重要，是专门用于向上一个活动返回数据的。setResult()方法接收两个参数，第一个参数用于向上一个活动返回处理结果，一般只使用 RESULT_OK 或 RESULT_CANCELED 这两个值，第二个参数则把带有数据的 Intent 传递回去，然后调用了 finish()方法来销毁当前活
动。
```

由于我们是使用 startActivityForResult()方法来启动 SecondActivity 的，在 SecondActivity 被销毁之后会回调上一个活动的 onActivityResult()方法，因此我们需要在 FirstActivity 中重 写这个方法来得到返回的数据

```java
@Override
protected void onActivityResult(int requestCode, int resultCode, @Nullable Intent data) {
    switch(requestCode){
        case 1:
            if(resultCode == RESULT_OK){
                String data_retrun = data.getStringExtra("data_return");
                Log.d("FirstActivity", data_retrun);
            }
            break;
        default:
    }
}
onActivityResult()方法带有三个参数，第一个参数 requestCode，即我们在启动活动时传入的请求码。第二个参数 resultCode，即我们在返回数据时传入的处理结果。第三个参数data，即携带着返回数据的 Intent。由于在一个活动中有可能调用 startActivityForResult()方法去启动很多不同的活动，每一个活动返回的数据都会回调到onActivityResult()这个方法中，因此我们首先要做的就是通过检查 requestCode 的值来判断数据来源。确定数据是从SecondActivity 返回的之后，我们再通过 resultCode 的值来判断处理结果是否成功。最后从 data中取值并打印出来，这样就完成了向上一个活动返回数据的工作。
```

如果是在SecondActivity中使用Back键返回到FirstActivity中，

```java
@Override
public void onBackPressed() {
    Intent intent = new Intent();
    intent.putExtra("data_return", "Hello FirstActivity");
    setResult(RESULT_OK, intent);
    finish();
}
```

### 2.3 活动的生命周期

Android 是使用任务（Task）来管理活动的，一个任务就是一组存放在栈里的活动的集 合，这个栈也被称作返回栈（Back Stack）。在默认情况下，每当 我们启动了一个新的活动，它会在返回栈中入栈，并处于栈顶的位置。而每当我们按下 Back 键 或调用 finish()方法去销毁一个活动时，处于栈顶的活动会出栈，这时前一个入栈的活动就会 重新处于栈顶的位置。系统总是会显示处于栈顶的活动给用户。

![image-20210204222512705](D:\编程学习\MD笔记\第一行代码\2.1返回栈工作示意图.png)

#### 活动状态

-  运行状态：当一个活动位于返回栈的栈顶时，这时活动就处于运行状态。系统最不愿意回收的就是处于 运行状态的活动，因为这会带来非常差的用户体验。
- 暂停状态：当一个活动不再处于栈顶位置，但仍然可见时，这时活动就进入了暂停状态。你可能会觉得 既然活动已经不在栈顶了，还怎么会可见呢？这是因为并不是每一个活动都会占满整个屏幕的， 比如对话框形式的活动只会占用屏幕中间的部分区域，你很快就会在后面看到这种活动。处于暂 停状态的活动仍然是完全存活着的，系统也不愿意去回收这种活动（因为它还是可见的，回收可 见的东西都会在用户体验方面有不好的影响），只有在内存极低的情况下，系统才会去考虑回收 这种活动。
- 停止状态：当一个活动不再处于栈顶位置，并且完全不可见的时候，就进入了停止状态。系统仍然会为 这种活动保存相应的状态和成员变量，但是这并不是完全可靠的，当其他地方需要内存时，处于 停止状态的活动有可能会被系统回收。
- 销毁状态：当一个活动从返回栈中移除后就变成了销毁状态。系统会最倾向于回收处于这种状态的活 动，从而保证手机的内存充足。

#### 活动的生存期

Activity 类中定义了 7 个回调方法，覆盖了活动生命周期的每一个环节

- onCreate()。这个方法你已经看到过很多次了，每个活动中我们都重写了这个方法，它会在活动第一次被创建的时候调用。你应该在这个方法中完成活动的初始化操作，比如 说加载布局、绑定事件等。
- onStart()。这个方法在活动由不可见变为可见的时候调用。 
- onResume()。这个方法在活动准备好和用户进行交互的时候调用。此时的活动一定位于 返回栈的栈顶，并且处于运行状态。
- onPause()。这个方法在系统准备去启动或者恢复另一个活动的时候调用。我们通常会在 这个方法中将一些消耗 CPU 的资源释放掉，以及保存一些关键数据，但这个方法的执行 速度一定要快，不然会影响到新的栈顶活动的使用。
- onStop()。这个方法在活动完全不可见的时候调用。它和 onPause()方法的主要区别在 于，如果启动的新活动是一个对话框式的活动，那么 onPause()方法会得到执行，而 onStop()方法并不会执行。 
- onDestroy()。这个方法在活动被销毁之前调用，之后活动的状态将变为销毁状态。
- onRestart()。这个方法在活动由停止状态变为运行状态之前调用，也就是活动被重新 启动了。

以上 7 个方法中除了 onRestart()方法，其他都是两两相对的，从而又可以将活动分为 3 种生存期。

- 完整生存期。活动在 onCreate()方法和 onDestroy()方法之间所经历的，就是完整生存 期。一般情况下，一个活动会在 onCreate()方法中完成各种初始化操作，而在 onDestroy()方法中完成释放内存的操作。
- 可见生存期。活动在 onStart()方法和 onStop()方法之间所经历的，就是可见生存期。 在可见生存期内，活动对于用户总是可见的，即便有可能无法和用户进行交互。我们可以通过这两个方法，合理地管理那些对用户可见的资源。比如在 onStart()方法中对资源进行加载，而在 onStop()方法中对资源进行释放，从而保证处于停止状态的活动不会占用过多内存。
-  前台生存期。活动在 onResume()方法和 onPause()方法之间所经历的就是前台生存期。 在前台生存期内，活动总是处于运行状态的，此时的活动是可以和用户进行交互的，我 们平时看到和接触最多的也就是这个状态下的活动。

![image-20210204224436632](D:\编程学习\MD笔记\第一行代码\2.2活动的生命周期.png)



#### 活动被回收了怎么办

Activity 中还提供了一个 onSaveInstanceState()回调方法，这个方 法可以保证在活动被回收之前一定会被调用，因此我们可以通过这个方法来解决活动被回收时临 时数据得不到保存的问题。

onSaveInstanceState()方法会携带一个 Bundle 类型的参数，Bundle 提供了一系列的方 法用于保存数据，比如可以使用 putString()方法保存字符串，使用 putInt()方法保存整型数 据，以此类推。每个保存方法需要传入两个参数，第一个参数是键，用于后面从 Bundle 中取值，第二个参数是真正要保存的内容。

```java
@Override
protected void onSaveInstanceState(Bundle outState) {
    super.onSaveInstanceState(outState);
    String tempData = "Something you just typed";
    outState.putString("data_key", tempData);
} 

@Override
protected void onCreate(Bundle savedInstanceState) {
    super.onCreate(savedInstanceState);
    Log.d(TAG, "onCreate");
    setContentView(R.layout.activity_main);
    if (savedInstanceState != null) {
        String tempData = savedInstanceState.getString("data_key");
        Log.d(TAG, tempData);
    }
    ...
} 
```

数据是已经保存下来了，那么我们应该在哪里进行恢复呢？细心的你也许早就发现，我们一 直使用的 onCreate()方法其实也有一个 Bundle 类型的参数。这个参数在一般情况下都是 null， 但是如果在活动被系统回收之前有通过 onSaveInstanceState()方法来保存数据的话，这个参 数就会带有之前所保存的全部数据，我们只需要再通过相应的取值方法将数据取出即可。



### 2.4 活动的启动模式

启动模式一共有 4 种，分别是 standard、singleTop、singleTask 和 singleInstance，可以在 AndroidManifest.xml 中通过给标签指定 android:launchMode 属性来选择启动模式。

#### standard

standard 是活动默认的启动模式，在不进行显式指定的情况下，所有活动都会自动使用这种 启动模式。对于使用 standard 模式的活动， 系统不会在乎这个活动是否已经在返回栈中存在，每次启动都会创建该活动的一个新的实例。

![2.3standard模式示意图](D:\编程学习\MD笔记\第一行代码\2.3standard模式示意图.png)

#### singleTop

当活动的启动模式指定为 singleTop，在启动活动时如果发现返回栈的栈顶已经是该活动，则认为可以直接使用它，不会再创建新的活动实例

![2.3standard模式示意图](D:\编程学习\MD笔记\第一行代码\2.3standard模式示意图.png)

#### singleTask

当活动的启动模式指定为 singleTask，每次启动该活动时系统首先会在返回栈中检查是否存在该活动的实例，如果发现已经存在则直接使用该实例，并把在这个活动之上的所有活动统统 出栈，如果没有发现就会创建一个新的活动实例。

![2.5singleTask模式示意图](D:\编程学习\MD笔记\第一行代码\2.5singleTask模式示意图.png)

在 SecondActivity 中启动 FirstActivity 时，会发现返 回栈中已经存在一个 FirstActivity 的实例，并且是在 SecondActivity 的下面，于是 SecondActivity 会从返回栈中出栈，而 FirstActivity 重新成为了栈顶活动，因此 FirstActivity 的 onRestart()方 法和 SecondActivity 的 onDestroy()方法会得到执行。现在返回栈中应该只剩下一个 FirstActivity 的实例了

#### singleInstance

不同于以上 3 种启动模式，指定为 singleInstance 模式的活动会启用一个新的返回栈来管理这个活动（其实如果 singleTask 模式指定了不同的 taskAffinity，也会启动一个新的返回栈）。

想象以下场景，假设我们的程序中有一个活动是允许其他程 序调用的，如果我们想实现其他程序和我们的程序可以共享这个活动的实例，应该如何实现呢？ 使用前面 3 种启动模式肯定是做不到的，因为每个应用程序都会有自己的返回栈，同一个活动在 不同的返回栈中入栈时必然是创建了新的实例。而使用 singleInstance 模式就可以解决这个问题， 在这种模式下会有一个单独的返回栈来管理这个活动，不管是哪个应用程序来访问这个活动，都 共用的同一个返回栈，也就解决了共享活动实例的问题。

![2.6singleInstance模式示意图](D:\编程学习\MD笔记\第一行代码\2.6singleInstance模式示意图.png)

### 2.5 活动的最佳实践

#### 知晓当前是哪一个活动

右击 com.example.activitytest 包→New→Java Class，在弹出的窗口出输入 BaseActivity。注意这里 BaseActivity 和普通活动的创建方式并不一样，因为我们不需要让 BaseActivity 在 AndroidManifest.xml 中注册，所以选择创建一个普通的 Java 类就可以了。然后 让 BaseActivity 继承自 AppCompatActivity，并重写 onCreate()方法。

```java
public class BaseActivity extends AppCompatActivity {
    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        Log.d("BaseActivity", getClass().getSimpleName());
    }
} 

```

接下来我们需要让 BaseActivity 成为 ActivityTest 项目中所有活动的父类。现在每当我们进入到一个活动的界面，该活动的类名就会被打印出来，这样我们就可以时时 刻刻知晓当前界面对应的是哪一个活动了

#### 随时随地退出程序

按 Home 键只是把程序挂起，并没有退出程序。其实这个问题就足 以引起你的思考，如果我们的程序需要一个注销或者退出的功能该怎么办呢？必须要有一个随时 随地都能退出程序的方案才行。其实解决思路也很简单，只需要用一个专门的集合类对所有的活动进行管理就可以了，下面 我们就来实现一下。

```java
//工具类名ActivityCollector.java


public class ActivityCollector {
    public static List<Activity> activities =  new ArrayList<>();

    public static void addActivity(Activity activity){
        activities.add(activity);
    }

    public static void removeActivity(Activity activity){
        activities.remove(activity);
    }

    public static void finishAll(){
        for(Activity activity : activities){
            if(!activity.isFinishing()){
                activity.finish();
            }
        }
        activities.clear();
    }
}

在活动管理器中，我们通过一个 List 来暂存活动，然后提供了一个 addActivity()方法用于向 List 中添加一个活动，提供了一个 removeActivity()方法用于从 List 中移除活动，最后提供了一个 finishAll()方法用于将 List 中存储的活动全部销毁掉。
```

在 BaseActivity 的 onCreate()方法中调用了 ActivityCollector 的 addActivity()方 法，表明将当前正在创建的活动添加到活动管理器里。然后在 BaseActivity 中重写 onDestroy() 方法，并调用了 ActivityCollector 的 removeActivity()方法，表明将一个马上要销毁的活 动从活动管理器里移除。从此以后，不管你想在什么地方退出程序，只需要调用 ActivityCollector.finishAll() 方法就可以了.

```java
public class BaseActivity extends AppCompatActivity {
    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        Log.d("BaseActivity", getClass().getSimpleName());
        ActivityCollector.addActivity(this);
    }
    @Override
    protected void onDestroy() {
        super.onDestroy();
        ActivityCollector.removeActivity(this);
    }
} 
```

当然你还可以在销毁所有活动的代码后面再加上杀掉当前进程的代码，以保证程序完全退 出，杀掉进程的代码如下所示：

```java
android.os.Process.killProcess(android.os.Process.myPid());

其中，killProcess()方法用于杀掉一个进程，它接收一个进程 id 参数，我们可以通过myPid()方法来获得当前程序的进程 id。
```

#### 启动一个活动的最佳写法

启动活动的方法相信你已经非常熟悉了，首先通过 Intent 构建出当前的“意图”，然后调用 startActivity()或 startActivityForResult()方法将活动启动起来，如果有数据需要从一 个活动传递到另一个活动，也可以借助 Intent 来完成。

假设 SecondActivity 中需要用到两个非常重要的字符串参数，在启动 SecondActivity 的时候 必须要传递过来，那么我们很容易会写出如下代码：

```java
Intent intent = new Intent(FirstActivity.this, SecondActivity.class);
intent.putExtra("param1", "data1");
intent.putExtra("param2", "data2");
startActivity(intent); 
```

但在真正开发时，经常两个Activity时不同人写的，但现在你负责的部分需要有启动 SecondActivity 这个功能，而你却不清楚启动这个活动需要传递哪些数据。这时无非就有两种办 法，一个是你自己去阅读 SecondActivity 中的代码，二是询问负责编写 SecondActivity 的同事。 你会不会觉得很麻烦呢？其实只需要换一种写法，就可以轻松解决掉上面的窘境。将SecondActivity中的代码修改为如下

```java
public class SecondActivity extends BaseActivity {
    public static void actionStart(Context context, String data1, String data2) {
        Intent intent = new Intent(context, SecondActivity.class);
        intent.putExtra("param1", data1);
        intent.putExtra("param2", data2);
        context.startActivity(intent);
    }
    ...
} 
```

## 3. UI开发

### 3.1 常用控件使用

#### TextView

它主要用于在界面上显示一段文本信息，TextView 中的文字默认是居左上角对齐的，

```java
<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
    android:orientation="vertical"
    android:layout_width="match_parent"
    android:layout_height="match_parent">

<TextView
    android:id="@+id/text_view"
    android:layout_width="match_parent"
    android:layout_height="wrap_content"
    android:text="This is Text View"
    />

</LinearLayout>
```

- android:id 给当前控件定义了一个唯一标识符
- android:layout_width 和 android:layout_height 指定了控件的宽度和高度。
  - match_parent 表示让当前 控件的大小和父布局的大小一样，也就是由父布局来决定当前控件的大小。
  - wrap_content 表示 让当前控件的大小能够刚好包含住里面的内容，也就是由控件内容决定当前控件的大小。
- android:text 指定 TextView 中显示的文本内容
- android:gravity 来指定文字的对齐方式，可选值有 top、bottom、left、right、 center 等，可以用“|”来同时指定多个值
- android:textSize 属性可以指定文字的大小
- android:textColor 属性可以指 定文字的颜色
- android: background 用于为布局或控件指定一个背景，可以使用颜色或图片来进行填充
- android:layout_margin 这个属性，它 可以指定控件在上下左右方向上偏移的距离，当然也可以使用 android:layout_marginLeft 或 android:layout_marginTop 等属性来单独指定控件在某个方向上偏移的距离

#### Button

它可配置的属性和 TextView 是差不多的

```xml
<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
              android:orientation="vertical"
              android:layout_width="match_parent"
              android:layout_height="match_parent">
    ...
    <Button
            android:id="@+id/button"
            android:layout_width="match_parent"
            android:layout_height="wrap_content"
            android:text="Button" />
</LinearLayout> 
```

由于系统会对 Button 中的所有英文字母自动进行大写转换，如果这不是 你想要的效果，可以使用 android:textAllCaps="false" 配置来禁用这一默认特性。

在创建好Layout后，在相对应的Activity中对Button进行点击事件注册

```java
public class MainActivity extends AppCompatActivity {
    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);
        Button button = (Button) findViewById(R.id.button); //findViewById返回的是View对象，需要进行向下转型成Button
        button.setOnClickListener(new View.OnClickListener() {
            @Override
            public void onClick(View v) {
                // 在此处添加逻辑
            }
        });
    }
}

//也可以使用实现接口的方式来进行注册

public class MainActivity extends AppCompatActivity implements View.OnClickListener {
    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);
        Button button = (Button) findViewById(R.id.button);
        button.setOnClickListener(this);
    }
    @Override
    public void onClick(View v) {
        switch (v.getId()) {
            case R.id.button:
                // 在此处添加逻辑
                break;
            default:
                break;
        }
    }
} 
```

#### TextView

```xml
<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
              android:orientation="vertical"
              android:layout_width="match_parent"
              android:layout_height="match_parent">
    ...
    <EditText
              android:id="@+id/edit_text"
              android:layout_width="match_parent"
              android:layout_height="wrap_content"
              android:hint="Type something here"
              />
</LinearLayout> 
```

- android:hint 属性指定了一段提示性的文本
- android:maxLines 属性指定文本输入的最大拉伸行数

点击Button获取EditText中的输入内容功能实现

```java
public class MainActivity extends AppCompatActivity implements View.OnClickListener {
    private EditText editText;
    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);
        Button button = (Button) findViewById(R.id.button);
        editText = (EditText) findViewById(R.id.edit_text);
        button.setOnClickListener(this);
    }
    @Override
    public void onClick(View v) {
        switch (v.getId()) {
            case R.id.button:
                String inputText = editText.getText().toString();
                Toast.makeText(MainActivity.this, inputText,
                               Toast.LENGTH_SHORT).show();
                break;
            default:
                break;
        }
    }
} 

在按钮的点击事件里调用 EditText的 getText()方法获取到输入的内容，再调用 toString()方法转换成字符串
```

#### ImageView

ImageView 是用于在界面上展示图片的一个控件。图片通常都是放在以“drawable”开头的目录下的。图片通常都是放在以“drawable”开头的目录下的。 目前我们的项目中有一个空的 drawable 目录，不过由于这个目录没有指定具体的分辨率，所以一 般不使用它来放置图片

```xml
<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
              android:orientation="vertical"
              android:layout_width="match_parent"
              android:layout_height="match_parent">
    ...
    <ImageView
               android:id="@+id/image_view"
               android:layout_width="wrap_content"
               android:layout_height="wrap_content"
               android:src="@drawable/img_1 "
               />
</LinearLayout> 
```

我们还可以在程序中通过代码动态地更改 ImageView 中的图片，然后修改 MainActivity 的代码

```java
public class MainActivity extends AppCompatActivity implements View.OnClickListener {

    private ImageView imageView;

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);
        imageView = (ImageView) findViewById(R.id.image_view);
        Button button1 = (Button) findViewById(R.id.button_1);
        button1.setOnClickListener(this);
    }

    @Override
    public void onClick(View v) {
        switch (v.getId()){
            case R.id.button_1:
                imageView.setImageResource(R.drawable.img_2);
                break;
            default:
                break;
        }
    }
}
```

#### ProgressBar/控件的可见属性

ProgressBar 用于在界面上显示一个进度条，表示我们的程序正在加载一些数据。

这里同时介绍控件的可见属性

所有的 Android 控件都具有这个属性，可以通过 android:visibility 进行指定，可选值有 3 种：visible、invisible 和 gone

- visible 表示控件是可见的，这个 值是默认值，不指定 android:visibility 时，控件都是可见的。
- invisible 表示控件不可见， 但是它仍然占据着原来的位置和大小，可以理解成控件变成透明状态了。
- gone 则表示控件不仅 不可见，而且不再占用任何屏幕空间

我们还可以通过代码来设置控件的可见性，使用的是 setVisibility()方法，可以传入 View.VISIBLE、View.INVISIBLE 和 View.GONE 这 3 种值。

下面通过按钮控制进度条的消失与显示

```java
public class MainActivity extends AppCompatActivity implements View.OnClickListener {

    private ImageView imageView;
    private ProgressBar progressBar;

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);
        imageView = (ImageView) findViewById(R.id.image_view);
        Button button1 = (Button) findViewById(R.id.button_1);
        progressBar = (ProgressBar) findViewById(R.id.progress_bar);
        button1.setOnClickListener(this);
    }

    @Override
    public void onClick(View v) {
        switch (v.getId()){
            case R.id.button_1:
                if(progressBar.getVisibility() == View.GONE){
                    progressBar.setVisibility(View.VISIBLE);
                }else{
                    progressBar.setVisibility(View.GONE);
                }
                break;
            default:
                break;
        }
    }
}
```

过 style 属性可以将ProgressBar指定成不同的样式

```xml
<ProgressBar
             android:id="@+id/progress_bar"
             android:layout_width="match_parent"
             android:layout_height="wrap_content"
             style="?android:attr/progressBarStyleHorizontal"
             android:max="100"
             />
```

指定成水平进度条后，我们还可以通过 android:max 属性给进度条设置一个最大值，然后 在代码中动态地更改进度条的进度

```java
public class MainActivity extends AppCompatActivity implements View.OnClickListener {

    private ImageView imageView;
    private ProgressBar progressBar;

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);
        imageView = (ImageView) findViewById(R.id.image_view);
        Button button1 = (Button) findViewById(R.id.button_1);
        progressBar = (ProgressBar) findViewById(R.id.progress_bar);
        button1.setOnClickListener(this);
    }

    @Override
    public void onClick(View v) {
        switch (v.getId()){
            case R.id.button_1:
                int progress = progressBar.getProgress();
                progress += 10;
                progressBar.setProgress(progress);
                break;
            default:
                break;
        }
    }
}
```

#### AlertDialog

AlertDialog 可以在当前的界面弹出一个对话框，这个对话框是置顶于所有界面元素之上的， 能够屏蔽掉其他控件的交互能力，因此 AlertDialog 一般都是用于提示一些非常重要的内容或者 警告信息。比如为了防止用户误删重要内容，在删除前弹出一个确认对话框

下面直接看代码

```java
public class MainActivity extends AppCompatActivity implements View.OnClickListener {

    private ImageView imageView;
    private ProgressBar progressBar;

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);
        imageView = (ImageView) findViewById(R.id.image_view);
        Button button1 = (Button) findViewById(R.id.button_1);
        progressBar = (ProgressBar) findViewById(R.id.progress_bar);
        button1.setOnClickListener(this);

    }

    @Override
    public void onClick(View v) {
        switch (v.getId()){
            case R.id.button_1:
                AlertDialog.Builder dialog = new AlertDialog.Builder(MainActivity.this);
                dialog.setTitle("This is Dialog");
                dialog.setMessage("Something important.");
                dialog.setCancelable(false);
                dialog.setPositiveButton("Ok", new DialogInterface.OnClickListener() {
                    @Override
                    public void onClick(DialogInterface dialog, int which) {

                    }
                });
                dialog.setNegativeButton("Cancle", new DialogInterface.OnClickListener() {
                    @Override
                    public void onClick(DialogInterface dialog, int which) {

                    }
                });
                dialog.show();

                break;
            default:
                break;
        }
    }
}
首先通过 AlertDialog.Builder 创建一个 AlertDialog 的实例，然后可以为这个对话框设置标题、内容、可否用 Back 键关闭对话框等属性，接下来调用 setPositiveButton()方法为对话框设置确定按钮的点击事件，调用 setNegativeButton()方法设置取消按钮的点击事件，最后调用show()方法将对话框显示出来
```

#### ProgressDialog

ProgressDialog 和 AlertDialog 有点类似，都可以在界面上弹出一个对话框，都能够屏蔽掉其 他控件的交互能力。不同的是，ProgressDialog 会在对话框中显示一个进度条，一般用于表示当 前操作比较耗时，让用户耐心地等待。

```java
public class MainActivity extends AppCompatActivity implements View.OnClickListener {
    ...
        @Override
        public void onClick(View v) {
        switch (v.getId()) {
            case R.id.button:
                ProgressDialog progressDialog = new ProgressDialog
                    (MainActivity.this);
                progressDialog.setTitle("This is ProgressDialog");
                progressDialog.setMessage("Loading...");
                progressDialog.setCancelable(true);
                progressDialog.show();
                break;
            default:
                break;
        }
    }
} 
如果在 setCancelable()中传入了 false，表示 ProgressDialog 是不能通过 Back 键取消掉的，这时你就一定要在代码中做好控制，当数据加载完成后必须要调用 ProgressDialog 的dismiss()方法来关闭对话框，否则 ProgressDialog 将会一直存在。
```

### 3.2 四种基本布局

![3.1布局和控件的关系](D:\编程学习\MD笔记\第一行代码\3.1布局和控件的关系.PNG)

#### 线性布局

- android:orientation 属性指定了排列方向，如果不指定 android:orientation 属性的值，默认的排列方向 就是 horizontal

- android:layout_gravity 属性，用于指定控件在布局中的对齐方式。它和我们上一节中学到的 android:gravity 属性看起来有些相似，这两个属性有什么区别呢？其实从名字就可以看出，android:gravity 用于指定文字在控件中的对齐方式。

  ```xml
  <LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
                android:orientation="horizontal"
                android:layout_width="match_parent"
                android:layout_height="match_parent">
      <Button
              android:id="@+id/button1"
              android:layout_width="wrap_content"
              android:layout_height="wrap_content"
              android:layout_gravity="top"
              android:text="Button 1" />
      <Button
              android:id="@+id/button2"
              android:layout_width="wrap_content"
              android:layout_height="wrap_content"
              android:layout_gravity="center_vertical"
              android:text="Button 2" />
      <Button
              android:id="@+id/button3"
              android:layout_width="wrap_content"
              android:layout_height="wrap_content"
              android:layout_gravity="bottom"
              android:text="Button 3" />
  </LinearLayout> 
  ```

  但是需要注意，当 LinearLayout 的排列方向是 horizontal 时，只有垂直方向上的对齐方式才会生效，因为此时水平方 向上的长度是不固定的，每添加一个控件，水平方向上的长度都会改变，因而无法指定该方向上 的对齐方式。同样的道理，当 LinearLayout 的排列方向是 vertical 时，只有水平方向上的对齐方式才会生效。

- android:layout_weight，这个 属性允许我们使用比例的方式来指定控件的大小，它在手机屏幕的适配性方面可以起到非常重要 的作用。比如我们正在编写一个消息发送界面，需要一个文本编辑框和一个发送按钮

```xml
<?xml version="1.0" encoding="utf-8"?>
<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
              android:orientation="horizontal"
              android:layout_width="match_parent"
              android:layout_height="match_parent">

    <EditText
              android:id="@+id/input_message"
              android:layout_width="0dp"
              android:layout_height="wrap_content"
              android:layout_weight="1"
              android:hint="Type something"/>

    <Button
            android:id="@+id/send"
            android:layout_width="0dp"
            android:layout_height="wrap_content"
            android:layout_weight="1"
            android:text="Send"
            />

</LinearLayout>
android:layout_weight 属性，此时控件的宽度就不应该再由 android:layout_width 来决定，这里指定成 0dp 是一种比较规范的写法。另外，dp 是 Android 中用于指定控件大小、间距等属性的单位，后面我们还会经常用到它。

其实原理也很简单，系统会先把 LinearLayout 下所有控件指定的 layout_weight 值相加，得到一个总值，然后每个控件所占大小的比例就是用该控件的 layout_weight 值除以刚才算出的总值。因此如果想让 EditText 占据屏幕宽度的 3/5，Button 占据屏幕宽度的 2/5，只需要将 EditText 的 layout_weight 改成 3，Button 的 layout_weight 改成 2 就可以了。
<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
              android:orientation="horizontal"
              android:layout_width="match_parent"
              android:layout_height="match_parent">
    <EditText
              android:id="@+id/input_message"
              android:layout_width="0dp"
              android:layout_height="wrap_content"
              android:layout_weight="1"
              android:hint="Type something"
              />
    <Button
            android:id="@+id/send"
            android:layout_width="wrap_content"
            android:layout_height="wrap_content"
            android:text="Send"
            />
</LinearLayout> 
这里我们仅指定了 EditText 的 android:layout_weight 属性，并将 Button 的宽度改回wrap_content。这表示 Button 的宽度仍然按照 wrap_content 来计算，而 EditText 则会占满屏幕所有的剩余空间。使用这种方式编写的界面，不仅在各种屏幕的适配方面会非常好，而且看起来也更加舒服。
```

#### 相对布局

它可以通过相对定位的方式让控件出现在布局的任何位置。

下面是控件相对于父布局进行定位

```xml
<RelativeLayout xmlns:android="http://schemas.android.com/apk/res/android"
                android:layout_width="match_parent"
                android:layout_height="match_parent">
    <Button
            android:id="@+id/button1"
            android:layout_width="wrap_content"
            android:layout_height="wrap_content"
            android:layout_alignParentLeft="true"
            android:layout_alignParentTop="true"
            android:text="Button 1" />
    <Button
            android:id="@+id/button2"
            android:layout_width="wrap_content"
            android:layout_height="wrap_content"
            android:layout_alignParentRight="true"
            android:layout_alignParentTop="true"
            android:text="Button 2" />
    <Button
            android:id="@+id/button3"
            android:layout_width="wrap_content" 
            android:layout_height="wrap_content"
            android:layout_centerInParent="true"
            android:text="Button 3" />
    <Button
            android:id="@+id/button4"
            android:layout_width="wrap_content"
            android:layout_height="wrap_content"
            android:layout_alignParentBottom="true"
            android:layout_alignParentLeft="true"
            android:text="Button 4" />
    <Button
            android:id="@+id/button5"
            android:layout_width="wrap_content"
            android:layout_height="wrap_content"
            android:layout_alignParentBottom="true"
            android:layout_alignParentRight="true"
            android:text="Button 5" />
</RelativeLayout> 
```

相对于控件进行定位

```xml
<?xml version="1.0" encoding="utf-8"?>
<RelativeLayout xmlns:android="http://schemas.android.com/apk/res/android"
                android:orientation="horizontal"
                android:layout_width="match_parent"
                android:layout_height="match_parent">
    <Button
            android:id="@+id/button3"
            android:layout_width="wrap_content"
            android:layout_height="wrap_content"
            android:layout_centerInParent="true"
            android:text="Button 3" />
    <Button
            android:id="@+id/button1"
            android:layout_width="wrap_content"
            android:layout_height="wrap_content"
            android:layout_above="@id/button3"
            android:layout_toLeftOf="@id/button3"
            android:text="Button 1" />
    <Button
            android:id="@+id/button2"
            android:layout_width="wrap_content"
            android:layout_height="wrap_content"
            android:layout_above="@id/button3"
            android:layout_toRightOf="@id/button3"
            android:text="Button 2" />
    <Button
            android:id="@+id/button4"
            android:layout_width="wrap_content"
            android:layout_height="wrap_content"
            android:layout_below="@id/button3"
            android:layout_toLeftOf="@id/button3"
            android:text="Button 4" />
    <Button
            android:id="@+id/button5"
            android:layout_width="wrap_content"
            android:layout_height="wrap_content"
            android:layout_below="@id/button3"
            android:layout_toRightOf="@id/button3"
            android:text="Button 5" />
</RelativeLayout>

当一个控件去引用另一个控件的 id 时，该控件一定要定义在引用控件的后面，不然会出现找不到 id 的情况

```

RelativeLayout 中还有另外一组相对于控件进行定位的属性，android:layout_alignLeft 表示让一个控件的左边缘和另一个控件的左边缘对齐，android:layout_alignRight 表示让一 个控件的右边缘和另一个控件的右边缘对齐。此外，还有 android:layout_alignTop 和 android:layout_alignBottom，道理都是一样的

#### 帧布局

FrameLayout 又称作帧布局，这种布局没有方便的定位方式，所有的控件都会默认摆放在布局的左上角

```xml
<FrameLayout xmlns:android="http://schemas.android.com/apk/res/android"
             android:layout_width="match_parent"
             android:layout_height="match_parent">
    <TextView
              android:id="@+id/text_view" 
              android:layout_width="wrap_content"
              android:layout_height="wrap_content"
              android:layout_gravity="left"
              android:text="This is TextView"
              />
    <ImageView
               android:id="@+id/button"
               android:layout_width="wrap_content"
               android:layout_height="wrap_content"
               android:layout_gravity="right"
               android:src="@mipmap/ic_launcher"
               />
</FrameLayout> 
```

#### 百分比布局

在这种布局中， 我们可以不再使用 wrap_content、match_parent 等方式来指定控件的大小，而是允许直接指 定控件在布局中所占的百分比，这样的话就可以轻松实现平分布局甚至是任意比例分割布局的效果了。

由于 LinearLayout 本身已经支持按比例指定控件的大小了，因此百分比布局只为 FrameLayout 和 RelativeLayout 进行了功能扩展，提供了 PercentFrameLayout 和 PercentRelativeLayout 这两个全新的布局

百分比布局属于新增布局。Android 团队将百分比布局定义在了 support 库当中，我们只需要在项目的 build.gradle 中添加百分比布局库的依赖，就能保证百分比布局在 Android 所有系统版本上的 兼容性了

打开 app/build.gradle 文件，在 dependencies 闭包中添加如下内容：





### 3.3 创建自定义控件

![3.2常用布局和控件的继承关系](D:\编程学习\MD笔记\第一行代码\3.2常用布局和控件的继承关系.PNG)

我们所用的所有控件都是直接或间接继承自 View 的，所用的所有布局都是直接 或间接继承自 ViewGroup 的。View 是 Android 中最基本的一种 UI 组件，它可以在屏幕上绘制一 块矩形区域，并能响应这块区域的各种事件，因此，我们使用的各种控件其实就是在 View 的基 础之上又添加了各自特有的功能。而 ViewGroup 则是一种特殊的 View，它可以包含很多子 View 和子 ViewGroup，是一个用于放置控件和布局的容器。

####  引入布局

一般我们的程序中可能有很多个活动都需要这样的标题栏，如果在每个活动的布局中都编 写一遍同样的标题栏代码，明显就会导致代码的大量重复。这个时候我们就可以使用引入布局的 方式来解决这个问题，新建一个布局 title.xml

```xml
<?xml version="1.0" encoding="utf-8"?>
<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
    android:layout_width="match_parent"
    android:layout_height="wrap_content"
    android:background="@drawable/title_bg">
    <Button
        android:id="@+id/title_back"
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:layout_gravity="center"
        android:layout_margin="5dp"
        android:background="@drawable/back_bg"
        android:text="Back"
        android:textColor="#fff" />
    <TextView
        android:id="@+id/title_text"
        android:layout_width="0dp"
        android:layout_height="wrap_content"
        android:layout_gravity="center"
        android:layout_weight="1"
        android:gravity="center"
        android:text="Title Text"
        android:textColor="#fff"
        android:textSize="24sp" />
    <Button
        android:id="@+id/title_edit"
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:layout_gravity="center"
        android:layout_margin="5dp"
        android:background="@drawable/edit_bg"
        android:text="Edit"
        android:textColor="#fff" />
</LinearLayout>
```

现在标题栏布局已经编写完成了，剩下的就是如何在程序中使用这个标题栏了，修改 activity_main.xml 中的代码

```xml
<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
              android:layout_width="match_parent"
              android:layout_height="match_parent" >
    <include layout="@layout/title" />
</LinearLayout> 
```

最后别忘了在 MainActivity 中将系统自带的标题栏隐藏掉

```java
public class MainActivity extends AppCompatActivity {
    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);
        ActionBar actionbar = getSupportActionBar();
        if (actionbar != null) {
            actionbar.hide();
        }
    }
} 
这里我们调用了 getSupportActionBar()方法来获得 ActionBar 的实例，然后再调用ActionBar 的 hide()方法将标题栏隐藏起来
```

#### 创建自定义控件控制布局

引入布局的技巧确实解决了重复编写布局代码的问题，但是如果布局中有一些控件要求能够 响应事件，我们还是需要在每个活动中为这些控件单独编写一次事件注册的代码。比如说标题栏 中的返回按钮，其实不管是在哪一个活动中，这个按钮的功能都是相同的，即销毁当前活动。而如果在每一个活动中都需要重新注册一遍返回按钮的点击事件，无疑会增加很多重复代码，这种 情况最好是使用自定义控件的方式来解决。

```java
public class TitleLayout extends LinearLayout {
    public TitleLayout(Context context, AttributeSet attrs) {
        super(context, attrs);
        LayoutInflater.from(context).inflate(R.layout.title, this);
    }
} 
首先我们重写了 LinearLayout 中带有两个参数的构造函数，在布局中引入 TitleLayout 控件就会调用这个构造函数。然后在构造函数中需要对标题栏布局进行动态加载，这就要借助LayoutInflater 来实现了。通过 LayoutInflater 的 from()方法可以构建出一个 LayoutInflater 对象，然后调用 inflate()方法就可以动态加载一个布局文件，inflate()方法接收两个参数，第一个参数是要加载的布局文件的 id，这里我们传入 R.layout.title，第二个参数是给加载好的布局再添加一个父布局，这里我们想要指定为 TitleLayout，于是直接传入 this。
```

```xml
<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
              android:layout_width="match_parent"
              android:layout_height="match_parent" >
    <com.example.uicustomviews.TitleLayout
                                           android:layout_width="match_parent"
                                           android:layout_height="wrap_content" />
        这里的layout_width和layout_height是将引入的TitleLayout整个标题栏看做一个整体进行控制
</LinearLayout> 
添加自定义控件和添加普通控件的方式基本是一样的，只不过在添加自定义控件的时候，我们需要指明控件的完整类名，包名在这里是不可以省略的。

```

下面我们尝试为标题栏中的按钮注册点击事件

```java
public class TitleLayout extends LinearLayout {

    public TitleLayout(Context context, AttributeSet attrs) {
        super(context, attrs);
        LayoutInflater.from(context).inflate(R.layout.title, this);
        Button titleBack = (Button) findViewById(R.id.title_back);
        Button titleEdit = (Button) findViewById(R.id.title_edit);

        titleBack.setOnClickListener(new OnClickListener() {
            @Override
            public void onClick(View v) {
                ((Activity)getContext()).finish();
            }
        });

        titleEdit.setOnClickListener(new OnClickListener() {
            @Override
            public void onClick(View v) {
                Toast.makeText(getContext(), "You clicked Edit button",
                        Toast.LENGTH_SHORT).show();
            }
        });
    }
}

首先还是通过findViewById()方法得到按钮的实例，然后分别调用setOnClickListener()方法给两个按钮注册了点击事件，当点击返回按钮时销毁掉当前的活动，当点击编辑按钮时弹出一段文本。
```

### 3.4 ListView

当我们的程序中有大量 的数据需要展示的时候，就可以借助 ListView 来实现。ListView 允许用户通过手指上下滑动的方 式将屏幕外的数据滚动到屏幕内，同时屏幕上原有的数据则会滚动出屏幕。

#### ListView的简单用法

```xml
<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
              android:layout_width="match_parent"
              android:layout_height="match_parent">
    <ListView
              android:id="@+id/list_view"
              android:layout_width="match_parent"
              android:layout_height="match_parent" />
</LinearLayout>
```

数组中的数据是无法直接传递给 ListView 的，我们还需要借助适配器来完成。Android 中提供了很多适配器的实现类，其中我认为最好用的就是 ArrayAdapter。它可以通过泛型来指定 要适配的数据类型，然后在构造函数中把要适配的数据传入。ArrayAdapter 有多个构造函数的重载，你应该根据实际情况选择最合适的一种。这里由于我们提供的数据都是字符串，因此将 ArrayAdapter 的泛型指定为 String，然后在 ArrayAdapter 的构造函数中依次传入当前上下文、 ListView 子项布局的 id，以及要适配的数据。注意，我们使用了 android.R.layout.simple_ list_item_1 作为 ListView 子项布局的 id，这是一个 Android 内置的布局文件，里面只有一个 TextView，可用于简单地显示一段文本。这样适配器对象就构建好了。 

最后，还需要调用 ListView 的 setAdapter()方法，将构建好的适配器对象传递进去，这样 ListView 和数据之间的关联就建立完成了。

```java
public class MainActivity extends AppCompatActivity {

    private String[] data = { "Apple", "Banana", "Orange", "Watermelon",
            "Pear", "Grape", "Pineapple", "Strawberry", "Cherry", "Mango",
            "Apple", "Banana", "Orange", "Watermelon", "Pear", "Grape",
            "Pineapple", "Strawberry", "Cherry", "Mango" };

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);
        ArrayAdapter<String> adapter = new ArrayAdapter<>(
                MainActivity.this, android.R.layout.simple_list_item_1, data);
        ListView listView = (ListView) findViewById(R.id.list_view);
        listView.setAdapter(adapter);

    }
}
```

#### 定制ListView界面

着定义一个实体类，作为 ListView 适配器的适配类型。新建类 Fruit，代码如下所示：

```java
public class Fruit {
    private String name;
    private  int imageId;

    public Fruit() {
    }

    public Fruit(String name, int imageId) {
        this.name = name;
        this.imageId = imageId;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public int getImageId() {
        return imageId;
    }

    public void setImageId(int imageId) {
        this.imageId = imageId;
    }
}

Fruit 类中只有两个字段，name 表示水果的名字，imageId 表示水果对应图片的资源 id。
```

然后需要为ListView的子项指定一个我们自定义的布局，在layout目录下新建fruit_item.xml。

```xml
<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
              android:orientation="vertical" 
              android:layout_width="match_parent"
              android:layout_height="wrap_content">

    <ImageView
               android:id="@+id/fruit_image"
               android:layout_width="wrap_content"
               android:layout_height="wrap_content" />

    <TextView
              android:id="@+id/fruit_name"
              android:layout_width="wrap_content"
              android:layout_height="wrap_content"
              android:layout_marginLeft="10dp" />

</LinearLayout>

在这个布局中，我们定义了一个 ImageView 用于显示水果的图片，又定义了一个 TextView用于显示水果的名称，并让 TextView 在垂直方向上居中显示。
```

接下来需要创建一个自定义的适配器，这个适配器继承自 ArrayAdapter，并将泛型指定为 Fruit 类。新建类 FruitAdapter，代码如下所示：

```java
public class FruitAdapter extends ArrayAdapter {
    private  int resourceId;

    public FruitAdapter(Context context, int resource, int textViewResourceId, List<Fruit> objects) {
        super(context, resource, textViewResourceId, objects);
        resourceId = textViewResourceId;
    }

    @Override
    public View getView(int position,  View convertView,  ViewGroup parent) {
        Fruit fruit = (Fruit) getItem(position); // 获取当前项的 Fruit 实例
        View view = LayoutInflater.from(getContext()).inflate(resourceId, parent, false);
        ImageView fruitImage = (ImageView) view.findViewById(R.id.fruit_image);
        TextView fruitName = (TextView) view.findViewById(R.id.fruit_name);

        fruitImage.setImageResource(fruit.getImageId());
        fruitName.setText(fruit.getName());
        return view;

    }
}
```

FruitAdapter 重写了父类的一组构造函数，用于将上下文、ListView 子项布局的 id 和数据 都传递进来。另外又重写了 getView()方法，这个方法在每个子项被滚动到屏幕内的时候会被调 用。在 getView()方法中，首先通过 getItem()方法得到当前项的 Fruit 实例，然后使用 LayoutInflater 来为这个子项加载我们传入的布局。

这里 LayoutInflater 的 inflate()方法接收 3 个参数，前两个参数我们已经知道是什么 意思了，第三个参数指定成 false，表示只让我们在父布局中声明的 layout 属性生效，但不会 为这个 View 添加父布局，因为一旦 View 有了父布局之后，它就不能再添加到 ListView 中了。 如果你现在还不能理解这段话的含义也没关系，只需要知道这是 ListView 中的标准写法就可以 了，当你以后对 View 理解得更加深刻的时候，再来读这段话就没有问题了。

我们继续往下看，接下来调用 View 的 findViewById()方法分别获取到 ImageView 和 TextView 的实例，并分别调用它们的 setImageResource()和 setText()方法来设置显示的图 片和文字，最后将布局返回

下面修改 MainActivity 中的代码

```java
public class MainActivity extends AppCompatActivity {
    private List<Fruit> fruitList = new ArrayList<>();
    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);
        initFruits(); // 初始化水果数据
        FruitAdapter adapter = new FruitAdapter(MainActivity.this,
                                                R.layout.fruit_item, fruitList);
        ListView listView = (ListView) findViewById(R.id.list_view);
        listView.setAdapter(adapter);
    }
    private void initFruits() {
        for (int i = 0; i < 2; i++) {
            Fruit apple = new Fruit("Apple", R.drawable.apple_pic);
            fruitList.add(apple);
            Fruit banana = new Fruit("Banana", R.drawable.banana_pic);
            fruitList.add(banana);
            Fruit orange = new Fruit("Orange", R.drawable.orange_pic);
            fruitList.add(orange);
            Fruit watermelon = new Fruit("Watermelon", R.drawable.watermelon_pic);
            fruitList.add(watermelon);
            Fruit pear = new Fruit("Pear", R.drawable.pear_pic);
            fruitList.add(pear);
            Fruit grape = new Fruit("Grape", R.drawable.grape_pic);
            fruitList.add(grape);
            Fruit pineapple = new Fruit("Pineapple", R.drawable.pineapple_pic);
            fruitList.add(pineapple);
            Fruit strawberry = new Fruit("Strawberry", R.drawable.strawberry_pic);
            fruitList.add(strawberry);
            Fruit cherry = new Fruit("Cherry", R.drawable.cherry_pic);
            fruitList.add(cherry);
            Fruit mango = new Fruit("Mango", R.drawable.mango_pic);
            fruitList.add(mango);
        }
    }
} 
```

#### 提升ListView的运行效率

目前我们 ListView 的运行效率是很低的，因为在 FruitAdapter 的 getView()方 法中，每次都将布局重新加载了一遍，当 ListView 快速滚动的时候，这就会成为性能的瓶颈。

仔细观察会发现，getView()方法中还有一个 convertView 参数，这个参数用于将之前加 载好的布局进行缓存，以便之后可以进行重用。修改 FruitAdapter 中的代码，如下所示：

```java
public class FruitAdapter extends ArrayAdapter<Fruit> {
    ...
        @Override
        public View getView(int position, View convertView, ViewGroup parent) {
        Fruit fruit = getItem(position);
        View view;
        if (convertView == null) {
            view = LayoutInflater.from(getContext()).inflate(resourceId, parent,
                                                             false);
        } else {
            view = convertView;
        }
        ImageView fruitImage = (ImageView) view.findViewById(R.id.fruit_image);
        TextView fruitName = (TextView) view.findViewById(R.id.fruit_name);
        fruitImage.setImageResource(fruit.getImageId());
        fruitName.setText(fruit.getName());
        return view;
    }
} 
```

不过，目前我们的这份代码还是可以继续优化的，虽然现在已经不会再重复去加载布局，但 是每次在 getView()方法中还是会调用 View 的 findViewById()方法来获取一次控件的实例。 我们可以借助一个 ViewHolder 来对这部分性能进行优化，修改 FruitAdapter 中的代码，如下 所示：

```java
public class FruitAdapter extends ArrayAdapter {
    private  int resourceId;

    public FruitAdapter(Context context, int textViewResourceId, List<Fruit> objects) {
        super(context, textViewResourceId, objects);
        resourceId = textViewResourceId;
    }

    public View getView(int position, View convertView, ViewGroup parent) {
        Fruit fruit = (Fruit) getItem(position);
        View view;
        ViewHolder viewHolder;
        if (convertView == null) {
            view = LayoutInflater.from(getContext()).inflate(resourceId, parent,
                    false);
            viewHolder = new ViewHolder();
            viewHolder.fruitImage = (ImageView) view.findViewById
                    (R.id.fruit_image);
            viewHolder.fruitName = (TextView) view.findViewById (R.id.fruit_name);
            view.setTag(viewHolder); // 将 ViewHolder 存储在 View 中
        } else {
            view = convertView;
            viewHolder = (ViewHolder) view.getTag(); // 重新获取 ViewHolder
        }
        viewHolder.fruitImage.setImageResource(fruit.getImageId());
        viewHolder.fruitName.setText(fruit.getName());
        return view;
    }

    class ViewHolder {
        ImageView fruitImage;
        TextView fruitName;
    }
}

```

我们新增了一个内部类 ViewHolder，用于对控件的实例进行缓存。当 convertView 为 null 的时候，创建一个 ViewHolder 对象，并将控件的实例都存放在 ViewHolder 里，然后调用 View 的 setTag()方法，将 ViewHolder 对象存储在 View 中。当 convertView 不为 null 的时候， 则调用 View 的 getTag()方法，把 ViewHolder 重新取出。这样所有控件的实例都缓存在了 ViewHolder 里，就没有必要每次都通过 findViewById()方法来获取控件实例了。

#### ListView的点击事件

本小节我们就来学习一下 ListView 如 何才能响应用户的点击事件。

```java
@Override
protected void onCreate(Bundle savedInstanceState) {
    super.onCreate(savedInstanceState);
    setContentView(R.layout.activity_main);
    initFruits(); // 初始化水果数据
    FruitAdapter adapter = new FruitAdapter(MainActivity.this, R.layout.fruit_item, fruitList);
    ListView listView = (ListView) findViewById(R.id.list_view);
    listView.setAdapter(adapter);
    listView.setOnItemClickListener(new AdapterView.OnItemClickListener() {
        @Override
        public void onItemClick(AdapterView<?> parent, View view, int position, long id) {
            Fruit fruit = fruitList.get(position);
            Toast.makeText(MainActivity.this, fruit.getName(), Toast.LENGTH_SHORT).show();
        }
    });
}
```



### 3.5 RecyclerView

Android 提供了一个更强大的滚动控件——RecyclerView。它可以说是一个增强版的 ListView，不仅可以轻松实现和 ListView 同样的效果，还优化了 ListView 中存在的各种不足之处。 目前 Android 官方更加推荐使用 RecyclerView

#### RecyclerView的基本用法

```xml
<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:app="http://schemas.android.com/apk/res-auto"
    xmlns:tools="http://schemas.android.com/tools"
    android:layout_width="match_parent"
    android:layout_height="match_parent"
    tools:context=".MainActivity">

    <androidx.recyclerview.widget.RecyclerView
        android:id="@+id/recycler_view"
        android:layout_width="match_parent"
        android:layout_height="match_parent"/>
</LinearLayout>

在布局中加入 RecyclerView 控件也是非常简单的，先为 RecyclerView 指定一个 id，然后将宽度和高度都设置为 match_parent，这样 RecyclerView 也就占满了整个布局的空间。
```

这里我们想要使用 RecyclerView 来实现和 ListView 相同的效果，因此就需要准备一份同样 的水果图片。简单起见，我们就直接从 ListViewTest 项目中把图片复制过来就可以了，另外顺便 将 Fruit 类和 fruit_item.xml 也复制过来，省得将同样的代码再写一遍。

接下来需要为 RecyclerView 准备一个适配器，新建 FruitAdapter 类，让这个适配器继承自 RecyclerView.Adapter，并将泛型指定为 FruitAdapter.ViewHolder。其中，ViewHolder 是我们在 FruitAdapter 中定义的一个内部类，代码如下所示：

```java
public class FruitAdapter extends RecyclerView.Adapter<FruitAdapter.ViewHolder> {
    private List<Fruit> mFruitList;

    static class ViewHolder extends RecyclerView.ViewHolder {
        ImageView fruitImage;
        TextView fruitName;

        public ViewHolder(View view) {
            super(view);
            fruitImage = (ImageView) view.findViewById(R.id.fruit_image);
            fruitName = (TextView) view.findViewById(R.id.fruit_name);
        }
    }

    public FruitAdapter(List<Fruit> fruitList) {
        mFruitList = fruitList;
    }

    @Override
    public ViewHolder onCreateViewHolder(ViewGroup parent, int viewType) {
        View view = LayoutInflater.from(parent.getContext())
                .inflate(R.layout.fruit_item, parent, false);
        ViewHolder holder = new ViewHolder(view);
        return holder;
    }

    @Override
    public void onBindViewHolder(ViewHolder holder, int position) {
        Fruit fruit = mFruitList.get(position);
        holder.fruitImage.setImageResource(fruit.getImageId());
        holder.fruitName.setText(fruit.getName());
    }

    @Override
    public int getItemCount() {
        return mFruitList.size();
    }
}

```



虽然这段代码看上去好像有点长，但其实它比 ListView 的适配器要更容易理解。这里我们首 先定义了一个内部类 ViewHolder，ViewHolder 要继承自 RecyclerView.ViewHolder。然后 ViewHolder 的构造函数中要传入一个 View 参数，这个参数通常就是 RecyclerView 子项的最外层布局，那么我们就可以通过 findViewById()方法来获取到布局中的 ImageView 和 TextView 的实例了。 接着往下看，FruitAdapter 中也有一个构造函数，这个方法用于把要展示的数据源传进来， 并赋值给一个全局变量 mFruitList，我们后续的操作都将在这个数据源的基础上进行。 继续往下看，由于 FruitAdapter 是继承自 RecyclerView.Adapter 的，那么就必须重写 onCreateViewHolder()、onBindViewHolder()和 getItemCount()这 3 个方法。onCreateViewHolder()方法是用于创建 ViewHolder 实例的，我们在这个方法中将 fruit_item 布局加载 进来，然后创建一个 ViewHolder 实例，并把加载出来的布局传入到构造函数当中，最后将 ViewHolder 的实例返回。onBindViewHolder()方法是用于对 RecyclerView 子项的数据进行赋值 的，会在每个子项被滚动到屏幕内的时候执行，这里我们通过 position 参数得到当前项的 Fruit 实例，然后再将数据设置到 ViewHolder 的 ImageView 和 TextView 当中即可。getItemCount() 方法就非常简单了，它用于告诉 RecyclerView 一共有多少子项，直接返回数据源的长度就可以了。

适配器准备好了之后，我们就可以开始使用 RecyclerView 了，修改 MainActivity 中的代码， 如下所示：

```java
public class MainActivity extends AppCompatActivity {

    private List<Fruit> fruitList = new ArrayList<>();

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);
        initFruits(); // 初始化水果数据
        RecyclerView recyclerView = (RecyclerView) findViewById(R.id.recycler_view);
        LinearLayoutManager layoutManager = new LinearLayoutManager(this);
        recyclerView.setLayoutManager(layoutManager);
        FruitAdapter adapter = new FruitAdapter(fruitList);
        recyclerView.setAdapter(adapter);
    }


    private void initFruits() {
        for (int i = 0; i < 2; i++) {
            Fruit apple = new Fruit("Apple", R.drawable.apple_pic);
            fruitList.add(apple);
            Fruit banana = new Fruit("Banana", R.drawable.banana_pic);
            fruitList.add(banana);
            Fruit orange = new Fruit("Orange", R.drawable.orange_pic);
            fruitList.add(orange);
            Fruit watermelon = new Fruit("Watermelon", R.drawable.watermelon_pic);
            fruitList.add(watermelon);
            Fruit pear = new Fruit("Pear", R.drawable.pear_pic);
            fruitList.add(pear);
            Fruit grape = new Fruit("Grape", R.drawable.grape_pic);
            fruitList.add(grape);
            Fruit pineapple = new Fruit("Pineapple", R.drawable.pineapple_pic);
            fruitList.add(pineapple);
            Fruit strawberry = new Fruit("Strawberry", R.drawable.strawberry_pic);
            fruitList.add(strawberry);
            Fruit cherry = new Fruit("Cherry", R.drawable.cherry_pic);
            fruitList.add(cherry);
            Fruit mango = new Fruit("Mango", R.drawable.mango_pic);
            fruitList.add(mango);
        }
    }
}
```

可以看到，这里使用了一个同样的 initFruits()方法，用于初始化所有的水果数据。接着 在 onCreate()方法中我们先获取到 RecyclerView 的实例，然后创建了一个 LinearLayoutManager 对象，并将它设置到 RecyclerView 当中。LayoutManager 用于指定 RecyclerView 的布局 方式，这里使用的 LinearLayoutManager 是线性布局的意思，可以实现和 ListView 类似的效果。 接下来我们创建了 FruitAdapter 的实例，并将水果数据传入到 FruitAdapter 的构造函数中， 最后调用 RecyclerView 的 setAdapter()方法来完成适配器设置，这样 RecyclerView 和数据之间 的关联就建立完成了。


#### 实现横向滚动和瀑布布局

首先要对 fruit_item 布局进行修改，因为目前这个布局里面的元素是水平排列的，适用于 纵向滚动的场景，而如果我们要实现横向滚动的话，应该把 fruit_item 里的元素改成垂直排列 才比较合理。修改 fruit_item.xml 中的代码，如下所示：

```xml
<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
              android:orientation="vertical"
              android:layout_width="100dp"
              android:layout_height="wrap_content" >
    <ImageView
               android:id="@+id/fruit_image"
               android:layout_width="wrap_content"
               android:layout_height="wrap_content"
               android:layout_gravity="center_horizontal" />
    <TextView
              android:id="@+id/fruit_name"
              android:layout_width="wrap_content"
              android:layout_height="wrap_content"
              android:layout_gravity="center_horizontal"
              android:layout_marginTop="10dp" />
</LinearLayout>

可以看到，我们将 LinearLayout 改成垂直方向排列，并把宽度设为 100dp。这里将宽度指定为固定值是因为每种水果的文字长度不一致，如果用 wrap_content 的话，RecyclerView 的子项就会有长有短，非常不美观；而如果用 match_parent 的话，就会导致宽度过长，一个子项占满整个屏幕。
然后我们将 ImageView 和 TextView 都设置成了在布局中水平居中，并且使用 layout_marginTop 属性让文字和图片之间保持一些距离。
```

```java
@Override
protected void onCreate(Bundle savedInstanceState) {
    super.onCreate(savedInstanceState);
    setContentView(R.layout.activity_main);
    initFruits(); // 初始化水果数据
    RecyclerView recyclerView = (RecyclerView) findViewById(R.id.recycler_view);
    LinearLayoutManager layoutManager = new LinearLayoutManager(this);
    layoutManager.setOrientation(LinearLayoutManager.HORIZONTAL);
    recyclerView.setLayoutManager(layoutManager);
    FruitAdapter adapter = new FruitAdapter(fruitList);
    recyclerView.setAdapter(adapter);
}
```

为什么 ListView 很难或者根本无法实现的效果在 RecyclerView 上这么轻松就能实现了呢？ 这主要得益于 RecyclerView出色的设计。ListView的布局排列是由自身去管理的，而 RecyclerView 则将这个工作交给了 LayoutManager，LayoutManager 中制定了一套可扩展的布局排列接口，子类 只要按照接口的规范来实现，就能定制出各种不同排列方式的布局了。

除了 LinearLayoutManager 之外，RecyclerView 还给我们提供了 GridLayoutManager 和 StaggeredGridLayoutManager 这两种内置的布局排列方式。GridLayoutManager 可以用于实现网格 布局，StaggeredGridLayoutManager 可以用于实现瀑布流布局。

首先还是来修改一下 fruit_item.xml 中的代码，如下所示

```java
public class MainActivity extends AppCompatActivity {

    private List<Fruit> fruitList = new ArrayList<>();

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);
        initFruits(); // 初始化水果数据
        RecyclerView recyclerView = (RecyclerView) findViewById(R.id.recycler_view);
        /*LinearLayoutManager layoutManager = new LinearLayoutManager(this);
        layoutManager.setOrientation(LinearLayoutManager.HORIZONTAL);*/
        StaggeredGridLayoutManager layoutManager = new
            StaggeredGridLayoutManager(3, StaggeredGridLayoutManager.VERTICAL);
        recyclerView.setLayoutManager(layoutManager);
        FruitAdapter adapter = new FruitAdapter(fruitList);
        recyclerView.setAdapter(adapter);
    }


    private void initFruits() {
        for (int i = 0; i < 2; i++) {
            Fruit apple = new Fruit(
                getRandomLengthName("Apple"), R.drawable.apple_pic);
            fruitList.add(apple);
            Fruit banana = new Fruit(
                getRandomLengthName("Banana"), R.drawable.banana_pic);
            fruitList.add(banana);
            Fruit orange = new Fruit(
                getRandomLengthName("Orange"), R.drawable.orange_pic);
            fruitList.add(orange);
            Fruit watermelon = new Fruit(
                getRandomLengthName("Watermelon"), R.drawable.watermelon_pic);
            fruitList.add(watermelon);
            Fruit pear = new Fruit(
                getRandomLengthName("Pear"), R.drawable.pear_pic);
            fruitList.add(pear);
            Fruit grape = new Fruit(
                getRandomLengthName("Grape"), R.drawable.grape_pic);
            fruitList.add(grape);
            Fruit pineapple = new Fruit(
                getRandomLengthName("Pineapple"), R.drawable.pineapple_pic);
            fruitList.add(pineapple);
            Fruit strawberry = new Fruit(
                getRandomLengthName("Strawberry"), R.drawable.strawberry_pic);
            fruitList.add(strawberry);
            Fruit cherry = new Fruit(
                getRandomLengthName("Cherry"), R.drawable.cherry_pic);
            fruitList.add(cherry);
            Fruit mango = new Fruit(
                getRandomLengthName("Mango"), R.drawable.mango_pic);
            fruitList.add(mango);
        }
    }
    private String getRandomLengthName(String name) {
        Random random = new Random();
        int length = random.nextInt(20) + 1;
        StringBuilder builder = new StringBuilder();
        for (int i = 0; i < length; i++) {
            builder.append(name);
        }
        return builder.toString();
    }
}

首先，在 onCreate()方法中，我们创建了一个 StaggeredGridLayoutManager 的实例。StaggeredGridLayoutManager 的构造函数接收两个参数，第一个参数用于指定布局的列数，传入 3 表示会把布局分为 3 列；第二个参数用于指定布局的排列方向，传入 StaggeredGridLayoutManager.VERTICAL 表示会让布局纵向排列，最后再把创建好的实例设置到RecyclerView当中就可以了，就是这么简单！
```

没错，仅仅修改了一行代码，我们就已经成功实现瀑布流布局的效果了。不过由于瀑布流布 局需要各个子项的高度不一致才能看出明显的效果，为此我又使用了一个小技巧。这里我们把眼 光聚焦在 getRandomLengthName()这个方法上，这个方法使用了 Random 对象来创造一个 1 到 20 之间的随机数，然后将参数中传入的字符串随机重复几遍。在 initFruits()方法中，每个水果 的名字都改成调用 getRandomLengthName()这个方法来生成，这样就能保证各水果名字的长短差距都比较大，子项的高度也就各不相同了。

#### RecyclerView的点击事件

和 ListView 一样，RecyclerView 也必须要能响应点击事件才可以，不然的话就没什么实际用 途了。不过不同于 ListView 的是，RecyclerView 并没有提供类似于 setOnItemClickListener() 这样的注册监听器方法，而是需要我们自己给子项具体的 View 去注册点击事件，相比于 ListView 来说，实现起来要复杂一些。

那么你可能就有疑问了，为什么 RecyclerView 在各方面的设计都要优于 ListView，偏偏在点 击事件上却没有处理得非常好呢？其实不是这样的，ListView 在点击事件上的处理并不人性化， setOnItemClickListener()方法注册的是子项的点击事件，但如果我想点击的是子项里具体的 某一个按钮呢？虽然 ListView 也是能做到的，但是实现起来就相对比较麻烦了。为此， RecyclerView 干脆直接摒弃了子项点击事件的监听器，所有的点击事件都由具体的 View 去注册， 就再没有这个困扰了。

下面我们来具体学习一下如何在 RecyclerView 中注册点击事件，修改 FruitAdapter 中的代 码，如下所示：

```java
public class FruitAdapter extends RecyclerView.Adapter<FruitAdapter.ViewHolder> {
    private List<Fruit> mFruitList;


    static class ViewHolder extends RecyclerView.ViewHolder {
        View fruitView;
        ImageView fruitImage;
        TextView fruitName;

        public ViewHolder(View view) {
            super(view);
            fruitView = view;
            fruitImage = (ImageView) view.findViewById(R.id.fruit_image);
            fruitName = (TextView) view.findViewById(R.id.fruit_name);
        }
    }

    public FruitAdapter(List<Fruit> fruitList) {
        mFruitList = fruitList;
    }

    @Override
    public ViewHolder onCreateViewHolder(ViewGroup parent, int viewType) {
        View view = LayoutInflater.from(parent.getContext())
                .inflate(R.layout.fruit_item, parent, false);
        final ViewHolder holder = new ViewHolder(view);
        holder.fruitView.setOnClickListener(new View.OnClickListener() {
            @Override
            public void onClick(View v) {
                int position = holder.getAdapterPosition();
                Fruit fruit = mFruitList.get(position);
                Toast.makeText(v.getContext(), "you clicked view " + fruit.getName(),
                        Toast.LENGTH_SHORT).show();
            }
        });
        holder.fruitImage.setOnClickListener(new View.OnClickListener() {
            @Override
            public void onClick(View v) {
                int position = holder.getAdapterPosition();
                Fruit fruit = mFruitList.get(position);
                Toast.makeText(v.getContext(), "you clicked image " + fruit.getName(),
                        Toast.LENGTH_SHORT).show();
            }
        });
        return holder;
    }

    @Override
    public void onBindViewHolder(ViewHolder holder, int position) {
        Fruit fruit = mFruitList.get(position);
        holder.fruitImage.setImageResource(fruit.getImageId());
        holder.fruitName.setText(fruit.getName());
    }

    @Override
    public int getItemCount() {
        return mFruitList.size();
    }
}


```

我们先是修改了 ViewHolder，在 ViewHolder 中添加了 fruitView 变量来保存子项最外层 布局的实例，然后在 onCreateViewHolder()方法中注册点击事件就可以了。这里分别为最外层 布局和 ImageView 都注册了点击事件，RecyclerView 的强大之处也在这里，它可以轻松实现子项 中任意控件或布局的点击事件。我们在两个点击事件中先获取了用户点击的 position，然后通过 position 拿到相应的 Fruit 实例，再使用 Toast 分别弹出两种不同的内容以示区别。

现在重新运行代码，并点击香蕉的图片部分，效果如图 3.37 所示。可以看到，这时触发了 ImageView 的点击事件。

### 3. 6 编写界面的最佳实践

在实战正式开始之前，我们还需要先学习一下如何制作 Nine-Patch 图片。你可能之前还没有 听说过这个名词，它是一种被特殊处理过的 png 图片，能够指定哪些区域可以被拉伸、哪些区域 不可以。

```xml
<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
    android:orientation="vertical"
    android:layout_width="match_parent"
    android:layout_height="match_parent"
    android:background="#d8e0e8"
    >

    <androidx.recyclerview.widget.RecyclerView
        android:id="@+id/msg_recycler_view"
        android:layout_width="match_parent"
        android:layout_height="0dp"
        android:layout_weight="1"/>
    <LinearLayout
        android:layout_width="match_parent"
        android:layout_height="wrap_content">

        <EditText
            android:id="@+id/input_tetxt"
            android:layout_width="0dp"
            android:layout_height="wrap_content"
            android:layout_weight="1"
            android:hint="Type Something here"
            android:maxLines="2"/>
        <Button
            android:id="@+id/send"
            android:layout_width="wrap_content"
            android:layout_height="wrap_content"
            android:text="Send"/>
    </LinearLayout>
</LinearLayout>
我们在主界面中放置了一个 RecyclerView 用于显示聊天的消息内容，又放置了一个 EditText用于输入消息，还放置了一个 Button 用于发送消息。
```

然后定义消息的实体类，新建 Msg，代码如下所示：

```java

package com.example.uibestpractice;

public class Msg {
    public static final int TYPE_RECEIVED = 0;

    public static final int TYPE_SENT = 1;

    private String content;

    private int type;

    public Msg() {
    }

    public Msg(String content, int type) {
        this.content = content;
        this.type = type;
    }

    public String getContent() {
        return content;
    }

    public void setContent(String content) {
        this.content = content;
    }

    public int getType() {
        return type;
    }

    public void setType(int type) {
        this.type = type;
    }
}
Msg 类中只有两个字段，content 表示消息的内容，type 表示消息的类型。其中消息类型有两个值可选，TYPE_RECEIVED 表示这是一条收到的消息，TYPE_SENT 表示这是一条发出的消息。
```

接着来编写 RecyclerView 子项的布局，新建 msg_item.xml，代码如下所示：

```xml
 <LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
    android:layout_width="match_parent"
    android:layout_height="wrap_content"
    android:orientation="vertical"
    android:padding="10dp">

    <LinearLayout
        android:id="@+id/left_layout"
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:layout_gravity="left"
        android:background="@drawable/message_left" >
        <TextView
            android:id="@+id/left_msg"
            android:layout_width="wrap_content"
            android:layout_height="wrap_content"
            android:layout_gravity="center"
            android:layout_margin="10dp"
            android:textColor="#fff" />
    </LinearLayout>

    <LinearLayout
        android:id="@+id/right_layout"
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:layout_gravity="right"
        android:background="@drawable/message_right" >
        <TextView
            android:id="@+id/right_msg"
            android:layout_width="wrap_content"
            android:layout_height="wrap_content"
            android:layout_gravity="center"
            android:layout_margin="10dp" />
    </LinearLayout>

</LinearLayout>
这里我们让收到的消息居左对齐，发出的消息居右对齐.你可能会有些疑虑，怎么能让收到的消息和发出的消息都放在
同一个布局里呢？不用担心，还记得我们前面学过的可见属性吗？
```

接下来需要创建 RecyclerView 的适配器类，新建类 MsgAdapter，代码如下所示：

```java
public class MsgAdapter extends RecyclerView.Adapter {

    private List<Msg> mMsgList;

    static class ViewHolder extends RecyclerView.ViewHolder{
        LinearLayout leftLayout;

        LinearLayout rightLayout;

        TextView leftMsg;

        TextView rightMsg;

        public ViewHolder(View view){
            super(view);
            leftLayout = (LinearLayout) view.findViewById(R.id.left_layout);
            rightLayout = (LinearLayout) view.findViewById(R.id.right_layout);
            leftMsg = (TextView) view.findViewById(R.id.left_msg);
            rightMsg = (TextView) view.findViewById(R.id.right_msg);

        }

    }

    public MsgAdapter(List<Msg> msgList) {
        this.mMsgList = msgList;
    }


    @Override
    public ViewHolder onCreateViewHolder(ViewGroup parent, int viewType) {
        View view = LayoutInflater.from(parent.getContext()).inflate(R.layout.msg_item, parent, false);
        return new ViewHolder(view);

    }

    @Override
    public void onBindViewHolder(@NonNull RecyclerView.ViewHolder holder, int position) {
        Msg msg = mMsgList.get(position);
        ViewHolder viewHolder = (ViewHolder)holder;
        if(msg.getType() == Msg.TYPE_RECEIVED){
            // 如果是收到的消息，则显示左边的消息布局，将右边的消息布局隐藏
            viewHolder.leftLayout.setVisibility(View.VISIBLE);
            viewHolder.rightLayout.setVisibility(View.GONE);

            ((ViewHolder) holder).leftMsg.setText(msg.getContent());

        }else if(msg.getType() == Msg.TYPE_SENT) {
            // 如果是发出的消息，则显示右边的消息布局，将左边的消息布局隐藏
            viewHolder.rightLayout.setVisibility(View.VISIBLE);
            viewHolder.leftLayout.setVisibility(View.GONE);
            viewHolder.rightMsg.setText(msg.getContent());
        }
    }


    @Override
    public int getItemCount() {
        return mMsgList.size();
    }
}

```

最后修改 MainActivity 中的代码，来为 RecyclerView 初始化一些数据，并给发送按钮加入事 件响应，代码如下所示：

```java
public class MainActivity extends AppCompatActivity {

    private List<Msg> msgList = new ArrayList<>();
    private EditText inputText;
    private Button send;
    private RecyclerView msgRecyclerView;
    private MsgAdapter adapter;

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);
        inputText = (EditText) findViewById(R.id.input_tetxt);
        send = (Button) findViewById(R.id.send);

        msgRecyclerView= (RecyclerView) findViewById(R.id.msg_recycler_view);
        LinearLayoutManager layoutManager = new LinearLayoutManager(this);
        msgRecyclerView.setLayoutManager(layoutManager);

        adapter = new MsgAdapter(msgList);
        msgRecyclerView.setAdapter(adapter);
        initMsgs(); 
        send.setOnClickListener(new View.OnClickListener() {
            @Override
            public void onClick(View v) {
                String content = inputText.getText().toString();
                Msg msg = new Msg(content, Msg.TYPE_SENT);
                msgList.add(msg);
                adapter.notifyItemInserted(msgList.size() - 1);
                // 当有新消息时，刷新 RecyclerView 中的显示
                msgRecyclerView.scrollToPosition(msgList.size() - 1);
                // 将RecyclerView 定位到最后一行
                inputText.setText(""); // 清空输入框中的内容

            }
        });



    }

    private void initMsgs() {
        Msg msg1 = new Msg("Hello guy.", Msg.TYPE_RECEIVED);
        msgList.add(msg1);
        Msg msg2 = new Msg("Hello. Who is that?", Msg.TYPE_SENT);
        msgList.add(msg2);
        Msg msg3 = new Msg("This is Tom. Nice talking to you. ", Msg.TYPE_RECEIVED);
        msgList.add(msg3);
    }

}
在 initMsgs()方法中我们先初始化了几条数据用于在 RecyclerView 中显示。然后在发送按钮的点击事件里获取了 EditText 中的内容，如果内容不为空字符串则创建出一个新的 Msg 对象，并把它添加到 msgList 列表中去。之后又调用了适配器的 notifyItemInserted()方法，用于通知列表有新的数据插入，这样新增的一条消息才能够在 RecyclerView 中显示。接着调用RecyclerView 的 scrollToPosition()方法将显示的数据定位到最后一行，以保证一定可以看得到最后发出的一条消息。最后调用 EditText 的 setText()方法将输入的内容清空。
```

## 4. 碎片

碎片（Fragment）是一种可以嵌入在活动当中的 UI 片段，它能让程序更加合理和充分地利 用大屏幕的空间，因而在平板上应用得非常广泛。你甚至可以将碎片理解成一个迷你型的活动，虽然这个迷你型的活动有可能和普通 的活动是一样大的。

### 4.1 碎片的使用

#### 碎片的简单使用

新建一个 FragmentTest 项目，然后开始我们的碎片探索之 旅吧

这里我们准备先写一个最简单的碎片示例来练练手，在一个活动当中添加两个碎片，并让这两个碎片平分活动空间。

新建一个左侧碎片布局 left_fragment.xml，代码如下所示：

```xml
<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
              android:orientation="vertical"
              android:layout_width="match_parent"
              android:layout_height="match_parent">
    <Button
            android:id="@+id/button"
            android:layout_width="wrap_content"
            android:layout_height="wrap_content"
            android:layout_gravity="center_horizontal"
            android:text="Button"
            />
</LinearLayout> 
```

这个布局非常简单，只放置了一个按钮，并让它水平居中显示。然后新建右侧碎片布局 right_fragment.xml，代码如下所示：

```xml
<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
              android:orientation="vertical"
              android:background="#00ff00"
              android:layout_width="match_parent"
              android:layout_height="match_parent">
    <TextView
              android:layout_width="wrap_content"
              android:layout_height="wrap_content"
              android:layout_gravity="center_horizontal"
              android:textSize="20sp"
              android:text="This is right fragment"
              />
</LinearLayout> 
```

可以看到，我们将这个布局的背景色设置成了绿色，并放置了一个 TextView 用于显示一段 文本。 接着新建一个 LeftFragment 类，并让它继承自 Fragment。注意，这里可能会有两个不同包 下的 Fragment 供你选择，一个是系统内置的 android.app.Fragment，一个是 support-v4 库中的 android.support.v4.app.Fragment。这里我强烈建议你使用 support-v4 库中的 Fragment，因为它可 以让碎片在所有 Android 系统版本中保持功能一致性

现在编写一下 LeftFragment 中的代码，如下所示：

```java
public class LeftFragment extends Fragment {
    @Override
    public View onCreateView(LayoutInflater inflater, ViewGroup container,
                             Bundle savedInstanceState) {
        View view = inflater.inflate(R.layout.left_fragment, container, false);
        return view;
    }
}
这里仅仅是重写了 Fragment 的 onCreateView()方法，然后在这个方法中通过 LayoutInflater
的 inflate()方法将刚才定义的 left_fragment 布局动态加载进来
```

接着我们 用同样的方法再新建一个 RightFragment，代码如下所示：

```java
public class RightFragment extends Fragment {
    @Override
    public View onCreateView(LayoutInflater inflater, ViewGroup container,
                             Bundle savedInstanceState) {
        View view = inflater.inflate(R.layout.right_fragment, container, false);
        return view;
    }
}
```

接下来修改 activity_main.xml 中的代码，如下所示：

```xml
<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
              android:orientation="horizontal"
              android:layout_width="match_parent"
              android:layout_height="match_parent" >
    <fragment
              android:id="@+id/left_fragment"
              android:name="com.example.fragmenttest.LeftFragment"
              android:layout_width="0dp"
              android:layout_height="match_parent"
              android:layout_weight="1" />
    <fragment
              android:id="@+id/right_fragment"
              android:name="com.example.fragmenttest.RightFragment"
              android:layout_width="0dp"
              android:layout_height="match_parent"
              android:layout_weight="1" />
</LinearLayout> 
可以看到，我们使用了<fragment>标签在布局中添加碎片，其中指定的大多数属性都是你
熟悉的，只不过这里还需要通过 android:name 属性来显式指明要添加的碎片类名，注意一定要
将类的包名也加上。
```

#### 动态添加碎片

碎片真正的强大之处在于， 它可以在程序运行时动态地添加到活动当中。根据具体情况来动态地添加碎片，你就可以将程序 界面定制得更加多样化。

我们还是在上一节代码的基础上继续完善，新建 another_right_fragment.xml，代码如下所示

```xml
<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
              android:orientation="vertical"
              android:background="#ffff00"
              android:layout_width="match_parent"
              android:layout_height="match_parent">
    <TextView
              android:layout_width="wrap_content"
              android:layout_height="wrap_content"
              android:layout_gravity="center_horizontal"
              android:textSize="20sp" 
              android:text="This is another right fragment"
              />
</LinearLayout> 
这个布局文件的代码和 right_fragment.xml 中的代码基本相同，只是将背景色改成了黄色，并
将显示的文字改了改。
```

然后新建 AnotherRightFragment 作为另一个右侧碎片，代码如下所示：

```java
public class AnotherRightFragment extends Fragment {
    @Override
    public View onCreateView(LayoutInflater inflater, ViewGroup container,
                             Bundle savedInstanceState) {
        View view = inflater.inflate(R.layout.another_right_fragment, container,
                                     false);
        return view;
    }
} 
代码同样非常简单，在 onCreateView()方法中加载了刚刚创建的 another_right_fragment 布
局。
```

这样我们就准备好了另一个碎片，接下来看一下如何将它动态地添加到活动当中。修改 activity_main.xml，代码如下所示：

```xml
<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
              android:orientation="horizontal"
              android:layout_width="match_parent"
              android:layout_height="match_parent" >
    <fragment
              android:id="@+id/left_fragment"
              android:name="com.example.fragmenttest.LeftFragment"
              android:layout_width="0dp"
              android:layout_height="match_parent"
              android:layout_weight="1" />
    <FrameLayout
                 android:id="@+id/right_layout"
                 android:layout_width="0dp"
                 android:layout_height="match_parent"
                 android:layout_weight="1" >
    </FrameLayout>
</LinearLayout> 
```

可以看到，现在将右侧碎片替换成了一个 FrameLayout 中，还记得这个布局吗？在上一章中 我们学过，这是 Android 中最简单的一种布局，所有的控件默认都会摆放在布局的左上角。由于 这里仅需要在布局里放入一个碎片，不需要任何定位，因此非常适合使用 FrameLayout。

下面我们将在代码中向 FrameLayout 里添加内容，从而实现动态添加碎片的功能。修改 MainActivity 中的代码，如下所示：

```java
public class MainActivity extends AppCompatActivity implements View.OnClickListener {
    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);
        Button button = (Button) findViewById(R.id.button);
        button.setOnClickListener(this);
        replaceFragment(new RightFragment());
    }
    @Override
    public void onClick(View v) {
        switch (v.getId()) {
            case R.id.button:
                replaceFragment(new AnotherRightFragment());
                break;
            default:
                break;
        }
    }
    private void replaceFragment(Fragment fragment) {
        FragmentManager fragmentManager = getSupportFragmentManager();
        FragmentTransaction transaction = fragmentManager.beginTransaction();
        transaction.replace(R.id.right_layout, fragment);
        transaction.commit();
    }
```

可以看到，首先我们给左侧碎片中的按钮注册了一个点击事件，然后调用 replaceFragment()方法动态添加了 RightFragment 这个碎片。当点击左侧碎片中的按钮时，又 会调用 replaceFragment() 方法将右侧碎片替换成 AnotherRightFragment 。

结合 replaceFragment()方法中的代码可以看出，动态添加碎片主要分为 5 步。

1. 创建待添加的碎片实例。 
2. 获取 FragmentManager，在活动中可以直接通过调用 getSupportFragmentManager()方 法得到。 
3. 开启一个事务，通过调用 beginTransaction()方法开启。 
4. 向容器内添加或替换碎片，一般使用 replace()方法实现，需要传入容器的 id 和待添加 的碎片实例。 
5. 提交事务，调用 commit()方法来完成。

#### 在碎片中模拟返回栈

我们成功实现了向活动中动态添加碎片的功能，不过你尝试一下就会发现， 通过点击按钮添加了一个碎片之后，这时按下 Back 键程序就会直接退出。如果这里我们想模仿 类似于返回栈的效果，按下 Back 键可以回到上一个碎片，该如何实现呢？

其实很简单，FragmentTransaction 中提供了一个 addToBackStack()方法，可以用于将一个 事务添加到返回栈中，修改 MainActivity 中的代码，如下所示：

```java
public class MainActivity extends AppCompatActivity implements View.OnClickListener {
    ...
        private void replaceFragment(Fragment fragment) {
        FragmentManager fragmentManager = getSupportFragmentManager();
        FragmentTransaction transaction = fragmentManager.beginTransaction();
        transaction.replace(R.id.right_layout, fragment);
        transaction.addToBackStack(null);
        transaction.commit();
    }

} 
```

这里我们在事务提交之前调用了 FragmentTransaction 的 addToBackStack()方法，它可以接 收一个名字用于描述返回栈的状态，一般传入 null 即可。现在重新运行程序，并点击按钮将 AnotherRightFragment 添加到活动中，然后按下 Back 键，你会发现程序并没有退出，而是回到了 RightFragment 界面，继续按下 Back 键，RightFragment 界面也会消失，再次按下 Back 键，程序 才会退出。

#### 碎片和活动之间的通信

虽然碎片都是嵌入在活动中显示的，可是实际上它们的关系并没有那么亲密。你可以看出， 碎片和活动都是各自存在于一个独立的类当中的，它们之间并没有那么明显的方式来直接进行通 信。如果想要在活动中调用碎片里的方法，或者在碎片中调用活动里的方法，应该如何实现呢？

为了方便碎片和活动之间进行通信，FragmentManager 提供了一个类似于 findViewById() 的方法，专门用于从布局文件中获取碎片的实例，代码如下所示：

```java
RightFragment rightFragment = (RightFragment) getSupportFragmentManager()
 .findFragmentById(R.id.right_fragment);
```

调用 FragmentManager 的 findFragmentById()方法，可以在活动中得到相应碎片的实例， 然后就能轻松地调用碎片里的方法了。

掌握了如何在活动中调用碎片里的方法，那在碎片中又该怎样调用活动里的方法呢？其实这 就更简单了，在每个碎片中都可以通过调用 getActivity()方法来得到和当前碎片相关联的活 动实例，代码如下所示：

```java
MainActivity activity = (MainActivity) getActivity();
```

有了活动实例之后，在碎片中调用活动里的方法就变得轻而易举了。另外当碎片中需要使用 Context 对象时，也可以使用 getActivity()方法，因为获取到的活动本身就是一个 Context 对象。

这时不知道你心中会不会产生一个疑问：既然碎片和活动之间的通信问题已经解决了，那么 碎片和碎片之间可不可以进行通信呢？

说实在的，这个问题并没有看上去那么复杂，它的基本思路非常简单，首先在一个碎片中可 以得到与它相关联的活动，然后再通过这个活动去获取另外一个碎片的实例，这样也就实现了不 同碎片之间的通信功能，因此这里我们的答案是肯定的。

### 4.2 碎片的生命周期

#### 碎片的状态和回调

还记得每个活动在其生命周期内可能会有哪几种状态吗？没错，一共有运行状态、暂停状态、 停止状态和销毁状态这 4 种。类似地，每个碎片在其生命周期内也可能会经历这几种状态，只不 过在一些细小的地方会有部分区别。

1. 运行状态：当一个碎片是可见的，并且它所关联的活动正处于运行状态时，该碎片也处于运行状态。
2. 暂停状态：当一个活动进入暂停状态时（由于另一个未占满屏幕的活动被添加到了栈顶），与它相关联 的可见碎片就会进入到暂停状态。
3. 停止状态：当一个活动进入停止状态时，与它相关联的碎片就会进入到停止状态，或者通过调用 FragmentTransaction 的 remove()、replace()方法将碎片从活动中移除，但如果在事务提交之 前调用 addToBackStack()方法，这时的碎片也会进入到停止状态。总的来说，进入停止状态的 碎片对用户来说是完全不可见的，有可能会被系统回收。
4. 销毁状态：碎片总是依附于活动而存在的，因此当活动被销毁时，与它相关联的碎片就会进入到销毁状 态。或者通过调用 FragmentTransaction 的 remove()、replace()方法将碎片从活动中移除，但 在事务提交之前并没有调用 addToBackStack()方法，这时的碎片也会进入到销毁状态。

不过碎片还提供了一些附加的回调方法，那我们就重点看一下这几个回调。

- onAttach()。当碎片和活动建立关联的时候调用。
- onCreateView()。为碎片创建视图（加载布局）时调用。
-  onActivityCreated()。确保与碎片相关联的活动一定已经创建完毕的时候调
- onDestroyView()。当与碎片关联的视图被移除的时候调用。 
- onDetach()。当碎片和活动解除关联的时候调用。

![碎片的生命周期](D:\编程学习\MD笔记\第一行代码\碎片的生命周期.png)

#### 体验碎片的声明周期

修改 RightFragment 中的代码，如下所示

```java
public class RightFragment extends Fragment {
    public static final String TAG = "RightFragment";

    @Override
    public void onAttach(Context context) {
        super.onAttach(context);
        Log.d(TAG, "onAttach");
    }

    @Override
    public void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        Log.d(TAG, "onCreate");
    }

    @Override
    public View onCreateView(LayoutInflater inflater, ViewGroup container,
                             Bundle savedInstanceState) {
        Log.d(TAG, "onCreateView");
        View view = inflater.inflate(R.layout.right_fragment, container, false);
        return view;
    }

    @Override
    public void onActivityCreated(Bundle savedInstanceState) {
        super.onActivityCreated(savedInstanceState);
        Log.d(TAG, "onActivityCreated");
    }

    @Override
    public void onStart() {
        super.onStart();
        Log.d(TAG, "onStart");
    }

    @Override
    public void onResume() {
        super.onResume();
        Log.d(TAG, "onResume");
    }

    @Override
    public void onPause() {
        super.onPause();
        Log.d(TAG, "onPause");
    }

    @Override
    public void onStop() {
        super.onStop();
        Log.d(TAG, "onStop");
    }

    @Override
    public void onDestroyView() {
        super.onDestroyView();
        Log.d(TAG, "onDestroyView");
    }

    @Override
    public void onDestroy() {
        super.onDestroy();
        Log.d(TAG, "onDestroy");
    }

    @Override
    public void onDetach() {
        super.onDetach();
        Log.d(TAG, "onDetach");
    }
}
```

另外值得一提的是，在碎片中你也是可以通过 onSaveInstanceState()方法来保存数据的， 因为进入停止状态的碎片有可能在系统内存不足的时候被回收。保存下来的数据在 onCreate()、 onCreateView()和 onActivityCreated()这 3 个方法中你都可以重新得到，它们都含有一个 Bundle 类型的 savedInstanceState 参数。具体的代码我就不在这里给出了，如果你忘记了该 如何编写，可以参考 2.4.5 小节。

### 4.3 动态加载布局的技巧

虽然动态添加碎片的功能很强大，可以解决很多实际开发中的问题，但是它毕竟只是在一个 布局文件中进行一些添加和替换操作。如果程序能够根据设备的分辨率或屏幕大小在运行时来决 定加载哪个布局，那我们可发挥的空间就更多了。因此本节我们就来探讨一下 Android 中动态加 载布局的技巧。

#### 使用限定符

如果你经常使用平板电脑，应该会发现现在很多的平板应用都采用的是双页模式（程序会在 左侧的面板上显示一个包含子项的列表，在右侧的面板上显示内容），因为平板电脑的屏幕足够 大，完全可以同时显示下两页的内容，但手机的屏幕一次就只能显示一页的内容，因此两个页面 需要分开显示。

那么怎样才能在运行时判断程序应该是使用双页模式还是单页模式呢？这就需要借助限定 符（Qualifiers）来实现了。下面我们通过一个例子来学习一下它的用法，修改 FragmentTest 项目 中的 activity_main.xml 文件，代码如下所示：

```xml
<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
              android:orientation="horizontal"
              android:layout_width="match_parent"
              android:layout_height="match_parent" >
    <fragment
              android:id="@+id/left_fragment"
              android:name="com.example.fragmenttest.LeftFragment"
              android:layout_width="match_parent"
              android:layout_height="match_parent"/>
</LinearLayout> 
```

这里将多余的代码都删掉，只留下一个左侧碎片，并让它充满整个父布局。接着在 res 目录 下新建 layout-large 文件夹，在这个文件夹下新建一个布局，也叫作 activity_main.xml，代码如下 所示：

```xml
<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
              android:orientation="horizontal"
              android:layout_width="match_parent"
              android:layout_height="match_parent">
    <fragment
              android:id="@+id/left_fragment"
              android:name="com.example.fragmenttest.LeftFragment"
              android:layout_width="0dp"
              android:layout_height="match_parent"
              android:layout_weight="1" />
    <fragment
              android:id="@+id/right_fragment"
              android:name="com.example.fragmenttest.RightFragment"
              android:layout_width="0dp"
              android:layout_height="match_parent"
              android:layout_weight="3" />
</LinearLayout> 
```

可以看到，layout/activity_main 布局只包含了一个碎片，即单页模式，而 layout-large/ activity_main 布局包含了两个碎片，即双页模式。其中 large 就是一个限定符，那些屏幕被认为 是 large 的设备就会自动加载 layout-large 文件夹下的布局，而小屏幕的设备则还是会加载 layout 文件夹下的布局。

![Android中的限定符参考表](D:\编程学习\MD笔记\第一行代码\Android中的限定符参考表.png)

#### 使用最小宽度限定符

在上一小节中我们使用 large 限定符成功解决了单页双页的判断问题，不过很快又有一个 新的问题出现了，large 到底是指多大呢？有的时候我们希望可以更加灵活地为不同设备加载布 局，不管它们是不是被系统认定为 large，这时就可以使用最小宽度限定符（Smallest-width Qualifier）了。

最小宽度限定符允许我们对屏幕的宽度指定一个最小值（以 dp 为单位），然后以这个最小值 为临界点，屏幕宽度大于这个值的设备就加载一个布局，屏幕宽度小于这个值的设备就加载另一 个布局。

 res 目录下新建 layout-sw600dp 文件夹，然后在这个文件夹下新建 activity_main.xml 布局， 代码如下所示：

```xml
LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
android:orientation="horizontal"
android:layout_width="match_parent"
android:layout_height="match_parent">

<fragment
          android:id="@+id/left_fragment"
          android:name="com.example.fragmenttest.LeftFragment"
          android:layout_width="0dp"
          android:layout_height="match_parent"
          android:layout_weight="1" />
<fragment
          android:id="@+id/right_fragment"
          android:name="com.example.fragmenttest.RightFragment"
          android:layout_width="0dp"
          android:layout_height="match_parent"
          android:layout_weight="3" />
</LinearLayout>
```

这就意味着，当程序运行在屏幕宽度大于等于 600dp 的设备上时，会加载 layout-sw600dp/ activity_main 布局，当程序运行在屏幕宽度小于 600dp 的设备上时，则仍然加载默认的 layout/ activity_main 布局。

#### 碎片的最佳实践--简易版新闻应用

前面有提到过，碎片很多时候都是在平板开发当中使用的，主要是为了解决屏幕空间不能充 分利用的问题。那是不是就表明，我们开发的程序都需要提供一个手机版和一个 Pad 版呢？确实 有不少公司都是这么做的，但是这样会浪费很多的人力物力。因为维护两个版本的代码成本很高， 每当增加什么新功能时，需要在两份代码里各写一遍，每当发现一个 bug 时，需要在两份代码里 各修改一次。因此今天我们最佳实践的内容就是，教你如何编写同时兼容手机和平板的应用程序。



##  5. 广播机制

这是因为 Android 中的每个应用程序都可以对 自己感兴趣的广播进行注册，这样该程序就只会接收到自己所关心的广播内容，这些广播可能是 来自于系统的，也可能是来自于其他应用程序的。Android 提供了一套完整的 API，允许应用程 序自由地发送和接收广播。

- 标准广播（Normal broadcasts）是一种完全异步执行的广播，在广播发出之后，所有的广 播接收器几乎都会在同一时刻接收到这条广播消息，因此它们之间没有任何先后顺序可 言。这种广播的效率会比较高，但同时也意味着它是无法被截断的。

  

  ![image-20210208093540657](D:\编程学习\MD笔记\第一行代码\5.1标准广播工作示意图.png)

- 有序广播（Ordered broadcasts）则是一种同步执行的广播，在广播发出之后，同一时刻只 会有一个广播接收器能够收到这条广播消息，当这个广播接收器中的逻辑执行完毕后， 广播才会继续传递。所以此时的广播接收器是有先后顺序的，优先级高的广播接收器就 可以先收到广播消息，并且前面的广播接收器还可以截断正在传递的广播，这样后面的 广播接收器就无法收到广播消息了。

  ![image-20210208093710015](D:\编程学习\MD笔记\第一行代码\5.2有序广播工作示意图.png)

### 5.1 接收系统广播

Android 内置了很多系统级别的广播，我们可以在应用程序中通过监听这些广播来得到各种 系统的状态信息。比如手机开机完成后会发出一条广播，电池的电量发生变化会发出一条广播， 时间或时区发生改变也会发出一条广播，等等。如果想要接收到这些广播，就需要使用广播接收器

#### 动态注册监听网络变化

那么该如何创建一个广播接收器呢？其实只需要新建一个类，让它继承自 BroadcastReceiver，并重写父类的 onReceive()方法就行了。这样当有广播到来时，onReceive()方法就会得到执行，具体的逻辑就可以在这个方法中处理。

那我们就先通过动态注册的方式编写一个能够监听网络变化的程序，借此学习一下广播接收器的基本用法吧。新建一个 BroadcastTest 项目，然后修改 MainActivity 中的代码

```java
public class MainActivity extends AppCompatActivity {

    private IntentFilter intentFilter;

    private NetworkChangeRecevier networkChangeRecevier;


    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);
        intentFilter = new IntentFilter();
        intentFilter.addAction(ConnectivityManager.CONNECTIVITY_ACTION);
        networkChangeRecevier = new NetworkChangeRecevier();
        registerReceiver(networkChangeRecevier, intentFilter);
    }

    @Override
    protected void onDestroy() {
        super.onDestroy();
        unregisterReceiver(networkChangeRecevier);
    }

    class NetworkChangeRecevier extends BroadcastReceiver{

        @Override
        public void onReceive(Context context, Intent intent) {
            Toast.makeText(context, "network changes", Toast.LENGTH_SHORT).show();
        }
    }
}
```

可以看到，我们在 MainActivity 中定义了一个内部类 NetworkChangeReceiver，这个类是 继承自 BroadcastReceiver 的，并重写了父类的 onReceive()方法。这样每当网络状态发生变 化时，onReceive()方法就会得到执行，这里只是简单地使用 Toast 提示了一段文本信息。

然后观察 onCreate()方法，首先我们创建了一个 IntentFilter 的实例，并给它添加了一 个值为 ConnectivityManager.CONNECTIVITY_ACTION 的 action，为什么要添加这个值呢？因为当 网络状态发生变化时，系统发出的正是一条值为 android.net.conn.CONNECTIVITY_CHANGE 的 广播，也就是说我们的广播接收器想要监听什么广播，就在这里添加相应的 action。接下来创建 了一个 NetworkChangeReceiver 的实例，然后调用 registerReceiver()方法进行注册，将 NetworkChangeReceiver 的实例和 IntentFilter 的实例都传了进去，这样 NetworkChangeReceiver 就会收到所有值为 ConnectivityManager.CONNECTIVITY_ACTION 的广播，也就实现了监听网络变化的功能。

最后要记得，动态注册的广播接收器一定都要取消注册才行，这里我们是在 onDestroy() 方法中通过调用 unregisterReceiver()方法来实现的。

整体来说，代码还是非常简单的，现在运行一下程序。首先你会在注册完成的时候收到一条 广播，然后按下 Home 键回到主界面（注意不能按 Back 键，否则 onDestroy()方法会执行），接 着打开 Settings 程序→Data usage 进入到数据使用详情界面，然后尝试着开关 Cellular data 按钮来 启动和禁用网络，你就会看到有 Toast 提醒你网络发生了变化。

不过，只是提醒网络发生了变化还不够人性化，最好是能准确地告诉用户当前是有网络还是 没有网络，因此我们还需要对上面的代码进行进一步的优化。

```java
public class MainActivity extends AppCompatActivity {

    private IntentFilter intentFilter;

    private NetworkChangeRecevier networkChangeRecevier;


    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);
        intentFilter = new IntentFilter();
        intentFilter.addAction(ConnectivityManager.CONNECTIVITY_ACTION);
        networkChangeRecevier = new NetworkChangeRecevier();
        registerReceiver(networkChangeRecevier, intentFilter);
    }

    @Override
    protected void onDestroy() {
        super.onDestroy();
        unregisterReceiver(networkChangeRecevier);
    }

    class NetworkChangeRecevier extends BroadcastReceiver {

        @Override
        public void onReceive(Context context, Intent intent) {
            ConnectivityManager connectivityManager = (ConnectivityManager)
                    getSystemService((Context.CONNECTIVITY_SERVICE));
            NetworkInfo networkInfo = connectivityManager.getActiveNetworkInfo();
            if (networkInfo != null && networkInfo.isAvailable()) {
                Toast.makeText(context, "network is available",
                        Toast.LENGTH_SHORT).show();
            } else {
                Toast.makeText(context, "network is unavailable",
                        Toast.LENGTH_SHORT).show();
            }

        }
    }
}
```

在 onReceive()方法中，首先通过 getSystemService()方法得到了 ConnectivityManager 的实例，这是一个系统服务类，专门用于管理网络连接的。然后调用它的 getActiveNetworkInfo()方法可以得到 NetworkInfo 的实例，接着调用 NetworkInfo 的 isAvailable()方法， 就可以判断出当前是否有网络了，最后我们还是通过 Toast 的方式对用户进行提示。

另外，这里有非常重要的一点需要说明，Android 系统为了保护用户设备的安全和隐私，做 了严格的规定：如果程序需要进行一些对用户来说比较敏感的操作，就必须在配置文件中声明权 限才可以，否则程序将会直接崩溃。比如这里访问系统的网络状态就是需要声明权限的。打开 AndroidManifest.xml 文件，在里面加入如下权限就可以访问系统网络状态了：

```xml
<manifest xmlns:android="http://schemas.android.com/apk/res/android" 
          package="com.example.broadcasttest">
    <uses-permission android:name="android.permission.ACCESS_NETWORK_STATE" />
    ...
</manifest> 
```

#### 静态注册实现开机启动

Background execution not allowed: receiving Intent 问题解决

当AndroiSDK版本大于等于25时，对隐式广播做了限制，这种限制主要是把广播用于进程间通信时，广播Receiver无法接收到广播，如果发生了此现象，可以通过shell下 logcat -s BroadcastQueue 可以看到是否报出了这样的警告。



动态注册的广播接收器可以自由地控制注册与注销，在灵活性方面有很大的优势，但是它也 存在着一个缺点，即必须要在程序启动之后才能接收到广播，因为注册的逻辑是写在 onCreate() 方法中的。那么有没有什么办法可以让程序在未启动的情况下就能接收到广播呢？这就需要使用 静态注册的方式了。

可以使用 Android Studio 提供的快捷方式来创建一 个广播接收器，直接搜索Broadcast Receiver。这里我们将广播接收器命名为 BootCompleteReceiver。 Exported 属性表示是否 允许这个广播接收器接收本程序以外的广播，Enabled 属性表示是否启用这个广播接收器。勾选 这两个属性。

```java
public class BootCompleteReceiver extends BroadcastReceiver {
    @Override
    public void onReceive(Context context, Intent intent) {
        Toast.makeText(context, "Boot Complete", Toast.LENGTH_LONG).show();
    }
}
代码非常简单，我们只是在 onReceive()方法中使用 Toast 弹出一段提示信息
```

静态的广播接收器一定要在 AndroidManifest.xml 文件中注册才可以使用，不过由于我 们是使用 Android Studio 的快捷方式创建的广播接收器，因此注册这一步已经被自动完成了。

```xml
<manifest xmlns:android="http://schemas.android.com/apk/res/android"
    package="com.example.broadcasttest">

    <uses-permission android:name="android.permission.ACCESS_NETWORK_STATE" />

    <application
        android:allowBackup="true"
        android:icon="@mipmap/ic_launcher"
        android:label="@string/app_name"
        android:roundIcon="@mipmap/ic_launcher_round"
        android:supportsRtl="true"
        android:theme="@style/Theme.BroadcastTest">
        <receiver
            android:name=".BootCompleteReceview"
            android:enabled="true"
            android:exported="true"></receiver>

        <activity android:name=".MainActivity">
            <intent-filter>
                <action android:name="android.intent.action.MAIN" />

                <category android:name="android.intent.category.LAUNCHER" />
            </intent-filter>
        </activity>
    </application>

</manifest>
```

不过目前 BootCompleteReceiver 还是不能接收到开机广播的，我们还需要对 AndroidManifest. xml 文件进行修改才行

```xml
<manifest xmlns:android="http://schemas.android.com/apk/res/android"
          package="com.example.broadcasttest">
    <uses-permission android:name="android.permission.ACCESS_NETWORK_STATE" />
    <uses-permission android:name="android.permission.RECEIVE_BOOT_COMPLETED" />
    <application
                 android:allowBackup="true"
                 android:icon="@mipmap/ic_launcher"
                 android:label="@string/app_name"
                 android:supportsRtl="true"
                 android:theme="@style/AppTheme">
        ...
        <receiver
                  android:name=".BootCompleteReceiver"
                  android:enabled="true"
                  android:exported="true">
            <intent-filter>
                <action android:name="android.intent.action.BOOT_COMPLETED" />
            </intent-filter>
        </receiver>
    </application>
</manifest> 

```

由于 Android 系统启动完成后会发出一条值为 android.intent.action.BOOT_COMPLETED 的广播，因此我们在标签里添加了相应的 action。另外，监听系统开机广播也 是需要声明权限的，可以看到，我们使用标签又加入了一条 android. permission.RECEIVE_BOOT_COMPLETED 权限。



### 5.2 发送自定义广播

#### 发送标准广播

在发送广播之前，我们还是需要先定义一个广播接收器来准备接收此广播才行，不然发出去 也是白发。因此新建一个 MyBroadcastReceiver

```java
public class MyBroadcastReceiver extends BroadcastReceiver {
    @Override
    public void onReceive(Context context, Intent intent) {
        Toast.makeText(context, "received ", Toast.LENGTH_SHORT).show();
    }

}
```

然后在 AndroidManifest.xml 中对这个广播接收器进行修改

```xml
<manifest xmlns:android="http://schemas.android.com/apk/res/android"
          package="com.example.broadcasttest">
    ...
    <application
                 android:allowBackup="true"
                 android:icon="@mipmap/ic_launcher"
                 android:label="@string/app_name"
                 android:supportsRtl="true"
                 android:theme="@style/AppTheme">
        ...
        <receiver
                  android:name=".MyBroadcastReceiver"
                  android:enabled="true"
                  android:exported="true">
            <intent-filter>
                <action android:name="com.example.broadcasttest.MY_BROADCAST"/>
            </intent-filter>
        </receiver>
    </application>
</manifest>
可以看到，这里让 MyBroadcastReceiver 接收一条值为 com.example.broadcasttest.
MY_BROADCAST 的广播
```

因此待会儿在发送广播的时候，我们就需要发出这样的一条广播。 接下来修改 activity_main.xml 中的代码

```xml
<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
              android:orientation="vertical"
              android:layout_width="match_parent"
              android:layout_height="match_parent" >
    <Button
            android:id="@+id/button"
            android:layout_width="match_parent"
            android:layout_height="wrap_content"
            android:text="Send Broadcast"
            />
</LinearLayout>
这里在布局文件中定义了一个按钮，用于作为发送广播的触发点。
```

然后修改 MainActivity 中 的代码

```java
public class MainActivity extends AppCompatActivity {
    ...
        @Override
        protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main); 
        Button button = (Button) findViewById(R.id.button);
        button.setOnClickListener(new View.OnClickListener() {
            @Override
            public void onClick(View v) {
                Intent intent = new
                    Intent("com.example.broadcasttest.MY_BROADCAST");
                sendBroadcast(intent);
            }
        });
        ...
    }
    ...
} 
```

#### 发送有序广播

广播是一种可以跨进程的通信方式，这一点从前面接收系统广播的时候就可以看出来了。因 此在我们应用程序内发出的广播，其他的应用程序应该也是可以收到的。为了验证这一点，我们需要再新建一个 BroadcastTest2 项目

AnotherBroadcastReceiver

```java
public class AnotherBroadcastReceiver extends BroadcastReceiver {
    @Override
    public void onReceive(Context context, Intent intent) {
        Toast.makeText(context, "received in AnotherBroadcastReceiver",
                       Toast.LENGTH_SHORT).show();
    }

} 
```

```xml
<manifest xmlns:android="http://schemas.android.com/apk/res/android"
          package="com.example.broadcasttest2">
    <application
                 android:allowBackup="true"
                 android:icon="@mipmap/ic_launcher"
                 android:label="@string/app_name"
                 android:supportsRtl="true"
                 android:theme="@style/AppTheme">
        ...
        <receiver
                  android:name=".AnotherBroadcastReceiver"
                  android:enabled="true"
                  android:exported="true">
            <intent-filter>
                <action android:name="com.example.broadcasttest.MY_BROADCAST" />
            </intent-filter>
        </receiver>
    </application>
</manifest>
可以看到，AnotherBroadcastReceiver 同样接收的是 com.example.broadcasttest.MY_
BROADCAST 这条广播。现在运行 BroadcastTest2 项目将这个程序安装到模拟器上，然后重新回到
BroadcastTest 项目的主界面，并点击一下 Send Broadcast 按钮，就会分别弹出两次提示信息
```

不过到目前为止，程序里发出的都还是标准广播，现在我们来尝试一下发送有序广播。重新 回到 BroadcastTest 项目，然后修改 MainActivity 中的代码

```java
public class MainActivity extends AppCompatActivity {
    ...
        @Override
        protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);
        Button button = (Button) findViewById(R.id.button);
        button.setOnClickListener(new View.OnClickListener() {
            @Override
            public void onClick(View v) {
                Intent intent = new
                    Intent("com.example.broadcasttest.MY_BROADCAST");
                sendOrderedBroadcast(intent, null);
            }
        });
        ...
    }
    ...
} 
可以看到，发送有序广播只需要改动一行代码，即将 sendBroadcast()方法改成sendOrderedBroadcast()方法。sendOrderedBroadcast()方法接收两个参数，第一个参数仍然是Intent，第二个参数是一个与权限相关的字符串，这里传入 null 就行了。
```

看上去好像和标准广播没什么区别嘛，不过别忘了，这个时候的广播接收器是有先后顺序的， 而且前面的广播接收器还可以将广播截断，以阻止其继续传播。 那么该如何设定广播接收器的先后顺序呢？当然是在注册的时候进行设定的了，修改 AndroidManifest.xml 中的代码

```xml
<manifest xmlns:android="http://schemas.android.com/apk/res/android"
          package="com.example.broadcasttest">
    <application
                 android:allowBackup="true"
                 android:icon="@mipmap/ic_launcher"
                 android:label="@string/app_name"
                 android:supportsRtl="true"
                 android:theme="@style/AppTheme">
        ...
        <receiver
                  android:name=".MyBroadcastReceiver"
                  android:enabled="true"
                  android:exported="true">
            <intent-filter android:priority="100">
                <action android:name="com.example.broadcasttest.MY_BROADCAST" />
            </intent-filter>
        </receiver>
    </application>
</manifest> 
可以看到，我们通过 android:priority 属性给广播接收器设置了优先级，优先级比较高的广播接收器就可以先收到广播。这里将 MyBroadcastReceiver 的优先级设成了 100，以保证它一定会在 AnotherBroadcastReceiver 之前收到广播
```

既然已经获得了接收广播的优先权，那么 MyBroadcastReceiver 就可以选择是否允许广播继 续传递了。修改 MyBroadcastReceiver 中的代码

```java
public class MyBroadcastReceiver extends BroadcastReceiver {
    @Override
    public void onReceive(Context context, Intent intent) {
        Toast.makeText(context, "received ", Toast.LENGTH_SHORT).show();
        abortBroadcast();
    }

}
如果在 onReceive()方法中调用了 abortBroadcast()方法，就表示将这条广播截断，后面的广播接收器将无法再接收到这条广播。
```

### 5.3 使用本地广播

前面我们发送和接收的广播全部属于系统全局广播，即发出的广播可以被其他任何应用程序 接收到，并且我们也可以接收来自于其他任何应用程序的广播。这样就很容易引起安全性的问题， 比如说我们发送的一些携带关键性数据的广播有可能被其他的应用程序截获，或者其他的程序不 停地向我们的广播接收器里发送各种垃圾广播。

为了能够简单地解决广播的安全性问题，Android 引入了一套本地广播机制，使用这个机制 发出的广播只能够在应用程序的内部进行传递，并且广播接收器也只能接收来自本应用程序发出 的广播，这样所有的安全性问题就都不存在了。

本地广播的用法并不复杂，主要就是使用了一个 LocalBroadcastManager 来对广播进行管理， 并提供了发送广播和注册广播接收器的方法。下面我们就通过具体的实例来尝试一下它的用法， 修改 MainActivity 中的代码

```java
public class MainActivity extends AppCompatActivity {
    private IntentFilter intentFilter;
    private LocalReceiver localReceiver;
    private LocalBroadcastManager localBroadcastManager;
    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);
        localBroadcastManager = LocalBroadcastManager.getInstance(this); // 获取实例
        Button button = (Button) findViewById(R.id.button);
        button.setOnClickListener(new View.OnClickListener() {
            @Override
            public void onClick(View v) {
                Intent intent = new Intent("com.example.broadcasttest.LOCAL_
                                           BROADCAST");
                                           localBroadcastManager.sendBroadcast(intent); 
                                           // 发送本地广播
                                           }
                                           });
                intentFilter = new IntentFilter();
                intentFilter.addAction("com.example.broadcasttest.LOCAL_BROADCAST");
                localReceiver = new LocalReceiver();
                localBroadcastManager.registerReceiver(localReceiver, intentFilter); // 注
                册本地广播监听器
            } 
            @Override
            protected void onDestroy() {
                super.onDestroy();
                localBroadcastManager.unregisterReceiver(localReceiver);
            }
            class LocalReceiver extends BroadcastReceiver {
                @Override
                public void onReceive(Context context, Intent intent) {
                    Toast.makeText(context, "received local broadcast", Toast.LENGTH_SHORT).
                        show();
                }
            }
        } 
```

有没有感觉这些代码很熟悉？没错，其实这基本上就和我们前面所学的动态注册广播接收器 以及发送广播的代码是一样的。只不过现在首先是通过 LocalBroadcastManager的 getInstance()方 法得到了它的一个实例，然后在注册广播接收器的时候调用的是 LocalBroadcastManager 的 registerReceiver()方法，在发送广播的时候调用的是LocalBroadcastManager的sendBroadcast() 方法，仅此而已。这里我们在按钮的点击事件里面发出了一条 com.example.broadcasttest. LOCAL_BROADCAST 广播，然后在 LocalReceiver 里去接收这条广播。

另外还有一点需要说明，本地广播是无法通过静态注册的方式来接收的。其实这也完全可以 理解，因为静态注册主要就是为了让程序在未启动的情况下也能收到广播，而发送本地广播时， 我们的程序肯定是已经启动了，因此也完全不需要使用静态注册的功能。

最后我们再来盘点一下使用本地广播的几点优势吧。

- 可以明确地知道正在发送的广播不会离开我们的程序，因此不必担心机密数据泄漏。 
- 其他的程序无法将广播发送到我们程序的内部，因此不需要担心会有安全漏洞的隐患。 
- 发送本地广播比发送系统全局广播将会更加高效。

### 5.4 最佳实践--实现强制下线功能

强制下线功能应该算是比较常见的了，很多的应用程序都具备这个功能，比如你的 QQ 号在 别处登录了，就会将你强制挤下线。其实实现强制下线功能的思路也比较简单，只需要在界面上 弹出一个对话框，让用户无法进行任何其他操作，必须要点击对话框中的确定按钮，然后回到登 录界面即可。可是这样就存在着一个问题，因为当我们被通知需要强制下线时可能正处于任何一 个界面，难道需要在每个界面上都编写一个弹出对话框的逻辑？如果你真的这么想，那思维就偏 远了，我们完全可以借助本章中所学的广播知识，来非常轻松地实现这一功能。新建一个 BroadcastBestPractice 项目，然后开始动手吧。



## 6. 数据持久化

### 6.1 以文件方式储存

#### 将数据存到文件中

文件存储是 Android 中最基本的一种数据存储方式，它不对存储的内容进行任何的格式化处 理，所有数据都是原封不动地保存到文件当中的，因而它比较适合用于存储一些简单的文本数据 或二进制数据。如果你想使用文件存储的方式来保存一些较为复杂的文本数据，就需要定义一套 自己的格式规范，这样可以方便之后将数据从文件中重新解析出来。

Context 类中提供了一个 openFileOutput()方法，可以用于将数据存储到指定的文件中。 这个方法接收两个参数，第一个参数是文件名，在文件创建的时候使用的就是这个名称，注意这 里指定的文件名不可以包含路径，因为所有的文件都是默认存储到/data/data//files/目录下的。第二个参数是文件的操作模式，主要有两种模式可选，MODE_PRIVATE 和 MODE_APPEND。其中 MODE_PRIVATE 是默认的操作模式，表示当指定同样文件名的时候， 所写入的内容将会覆盖原文件中的内容，而 MODE_APPEND 则表示如果该文件已存在，就往文 件里面追加内容，不存在就创建新文件。其实文件的操作模式本来还有另外两种： MODE_WORLD_READABLE 和 MODE_WORLD_WRITEABLE，这两种模式表示允许其他的应 用程序对我们程序中的文件进行读写操作，不过由于这两种模式过于危险，很容易引起应用的安 全性漏洞，已在 Android 4.2 版本中被废弃。 openFileOutput()方法返回的是一个 FileOutputStream 对象，得到了这个对象之后就可 以使用 Java 流的方式将数据写入到文件中了

```java
public void save() {
    String data = "Data to save";
    FileOutputStream out = null;
    BufferedWriter writer = null;
    try {
        out = openFileOutput("data", Context.MODE_PRIVATE);
        writer = new BufferedWriter(new OutputStreamWriter(out));
        writer.write(data);
    } catch (IOException e) {
        e.printStackTrace();
    } finally {
        try {
            if (writer != null) {
                writer.close();
            }
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
} 
这里通过 openFileOutput()方法能够得到一个 FileOutputStream 对象，然后再借助它构建出一个OutputStreamWriter 对象，接着再使用 OutputStreamWriter 构建出一个 BufferedWriter 对象，这样你就可以通过 BufferedWriter 来将文本内容写入到文件中了。
```



首先创建一个 FilePersistenceTest 项目，并修改 activity_main.xml 中的代码

```xml
<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
              android:orientation="vertical"
              android:layout_width="match_parent"
              android:layout_height="match_parent" >
    <EditText
              android:id="@+id/edit"
              android:layout_width="match_parent"
              android:layout_height="wrap_content"
              android:hint="Type something here"
              />
</LinearLayout> 
这里只是在布局中加入了一个 EditText，用于输入文本内容。其实现在你就可以运行一下程序了，界面上肯定会有一个文本输入框。然后在文本输入框中随意输入点什么内容，再按下 Back键，这时输入的内容肯定就已经丢失了，因为它只是瞬时数据，在活动被销毁后就会被回收。而这里我们要做的，就是在数据被回收之前，将它存储到文件当中。
```

```java
public class MainActivity extends AppCompatActivity {

    private EditText edit;

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);
        edit = (EditText) findViewById(R.id.edit);
    }

    @Override
    protected void onDestroy() {
        super.onDestroy();
        String inputText = edit.getText().toString();
        save(inputText);
    }

    public void save(String inputText) {
        FileOutputStream out = null;
        BufferedWriter writer = null;
        try {
            out = openFileOutput("data", Context.MODE_PRIVATE);
            writer = new BufferedWriter(new OutputStreamWriter(out));
            writer.write(inputText);
        } catch (IOException e) {
            e.printStackTrace();
        } finally {
            try {
                if (writer != null) {
                    writer.close();
                }
            } catch (IOException e) {
                e.printStackTrace();
            }
        }
    }
}
可以看到，首先我们在 onCreate()方法中获取了 EditText 的实例，然后重写了 onDestroy()方法，这样就可以保证在活动销毁之前一定会调用这个方法。在 onDestroy()方法中我们获取了 EditText 中输入的内容，并调用 save()方法把输入的内容存储到文件中，文件命名为 data。
```

我们可以借助Device File explorer查看保存的文件。在这里找到/data/data/com.example.filepersistencetest/files/目录，可以看到生成了 一个 data 文件

#### 从文件中读取数据

类似于将数据存储到文件中，Context 类中还提供了一个 openFileInput()方法，用于从 文件中读取数据。这个方法要比 openFileOutput()简单一些，它只接收一个参数，即要读取的 文件名，然后系统会自动到/data/data//files/目录下去加载这个文件，并返回一个 FileInputStream 对象，得到了这个对象之后再通过 Java 流的方式就可以将数据读取出来了

```java
public String load() {
    FileInputStream in = null;
    BufferedReader reader = null;
    StringBuilder content = new StringBuilder();
    try {
        in = openFileInput("data");
        reader = new BufferedReader(new InputStreamReader(in));
        String line = "";
        while ((line = reader.readLine()) != null) {
            content.append(line);
        }
    } catch (IOException e) {
        e.printStackTrace();
    } finally {
        if (reader != null) {
            try {
                reader.close();
            } catch (IOException e) {
                e.printStackTrace();
            }
        }
    }
    return content.toString();
} 
在这段代码中，首先通过 openFileInput()方法获取到了一个 FileInputStream 对象，然后借助它又构建出了一个 InputStreamReader 对象，接着再使用 InputStreamReader 构建出一个 BufferedReader 对象，这样我们就可以通过 BufferedReader 进行一行行地读取，把文件中所有的文本内容全部读取出来，并存放在一个 StringBuilder 对象中，最后将读取到的内容返回就可以了
```

我们就来继续完善上一小节中的例子，使得重新启动 程序时 EditText 中能够保留我们上次输入的内容

```java
public class MainActivity extends AppCompatActivity {
    private EditText edit;
    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);
        edit = (EditText) findViewById(R.id.edit);
        String inputText = load();
        if (!TextUtils.isEmpty(inputText)) {
            edit.setText(inputText);
            edit.setSelection(inputText.length());
            Toast.makeText(this, "Restoring succeeded", Toast.LENGTH_SHORT).show();
        }
    }
    ...
        public String load() {
        FileInputStream in = null;
        BufferedReader reader = null;
        StringBuilder content = new StringBuilder();
        try {
            in = openFileInput("data");
            reader = new BufferedReader(new InputStreamReader(in));
            String line = "";
            while ((line = reader.readLine()) != null) {
                content.append(line);
            }
        } catch (IOException e) {
            e.printStackTrace();
        } finally {
            if (reader != null) {
                try {
                    reader.close();
                } catch (IOException e) {
                    e.printStackTrace();
                }
            }
        }
        return content.toString();
    }
} 
可以看到，这里的思路非常简单，在 onCreate()方法中调用 load()方法来读取文件中存储的文本内容，如果读到的内容不为null，就调用EditText的setText()方法将内容填充到EditText里，并调用 setSelection()方法将输入光标移动到文本的末尾位置以便于继续输入，然后弹出一句还原成功的提示
```

不过正如我前面所说，文件存储的方式并不适合用于保存一些较为复杂的文本数据

### 6.3 Shared Preferences储存

不同于文件的存储方式，SharedPreferences 是使用键值对的方式来存储数据的。也就是说， 当保存一条数据的时候，需要给这条数据提供一个对应的键，这样在读取数据的时候就可以通过 这个键把相应的值取出来。而且 SharedPreferences 还支持多种不同的数据类型存储，如果存储的 数据类型是整型，那么读取出来的数据也是整型的；如果存储的数据是一个字符串，那么读取出 来的数据仍然是字符串。 这样你应该就能明显地感觉到，使用 SharedPreferences 来进行数据持久化要比使用文件方便很多。

#### 将数据存储到SharedPreferences中

